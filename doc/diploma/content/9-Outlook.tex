% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Ausblick}
Diese Kapitel soll dazu dienen Ideen für fortführende wissenschaftliche Arbeiten zu präsentieren. Des Weiteren werden Ideen zusammengetragen wie die derzeitige Version der Implementierung sinnvoll erweitert bzw. verbessert werden kann.

\section{Ideen zur Erweiterung der Implementierung}
Um aus den schon etwas fortgeschrittenen Prototypen, welcher im Rahme dieser Arbeit entstanden ist, eine vollwertige und nutzbare Applikation zumachen, bedarf es noch einiger Features welche implementiert werden müssten.\\
\\
Ein Punkt dieser Erweiterungen wäre eine vollwertige Nutzerverwaltung. Dafür müsste dem Nutzer in erster Linie eine Möglichkeit zur Anmeldung bereitgestellt werden. Nach einer erfolgreichen Authentifizierung sollten dem jeweiligen Nutzer nur noch seine eigenen Matches angezeigt werden.
Um anschließend auch gegen andere Player spielen zu können, müsste der Nutzer die Möglichkeit haben einen anderen einzuladen. Erst nach einer Annahme der Einladung sollte das Match gestartet werden können. Damit sich ein Nutzer überhaupt erst anmelden kann, müsste dieser sich vorerst über ein Formular registrieren. Die derzeitige Übersicht der Player würde durch eine solche Implementation überflüssig werden.\\
\\
Mit einer Nutzerverwaltung gehen natürlich auch Sicherheitsrisiken einher, weshalb ein Authentifizierungsverfahren verwendet werden sollte. Zur Auswahl stehen dabei beispielsweise die \enquote{basic access authentication}, welche bereits durch den \gls{HTTP}-Standard mitgeliefert wird oder aber das offene Protokoll \gls{OAuth}.\\
\\
Als letzte Idee zur Erweiterung, bzw. ist es in diesem Fall eine Verbesserung der Implementierung, wäre die Verwendung eines Multiplattform Projektes \cite{kotlinMultiPlattform}. Dieses Feature wurde mit der Version 1.2 von Kotlin veröffentlicht, befindet sich aber derzeit noch im experimentellem Stadium. Mithilfe dieses Features ist es möglich ein und denselben Kotlin-Code nach Java und JavaScript zu kompilieren. Damit wäre eine deutliche Ersparnis des zu schreibenden Quellcodes möglich. Da sich im gezeigten Beispiel viele Funktionen doppeln und auch die Klassenmodelle weitestgehend übereinstimmen, würde sich eine Verwendung dieses Features auf jeden Fall lohnen.

\section{Genauere Analyse des Konzeptes HATEOAS}
Wie bereits im \hyperref[sec:konzeptHATEOAS]{Kapitel~\ref{sec:konzeptHATEOAS}} erwähnt, gibt es noch weitere Verfahren um dieses Design-Konzept umzusetzen. Daher könnte sich eine fortführende wissenschaftliche Arbeit mit der Analyse dieser Varianten befassen. Dabei könnten die jeweiligen Vor- und Nachteile verglichen und gegebenenfalls ergründet werden für welchen Einsatzzweck welches Verfahren am besten geeignet ist.

\section{Lastverteilung von REST-APIs}
Im \hyperref[sec:statelessCommunikation]{Kapitel~\ref{sec:statelessCommunikation}} wurde erwähnt das sich \gls{REST}-\glspl{API}, durch ihre statuslose Kommunikation, besonders gut für eine Lastverteilung, auf mehrere Instanzen, eigenen. Interessant könnte hierbei eine Analyse der Möglichkeiten zur Umsetzung dieser Verteilung sein. Beispielsweise wäre da ein Aufbau eines Clusters mithilfe von Docker Swarm oder Kubernetes möglich. Da sich aber diese beiden Technologien auf Container-Anwendungen beziehen, wäre eine weitere Lösung ohne die Verwendung von Container denkbar.

\section{Weitere Vergleichsmöglichkeiten}
\hyperref[sec:comparison]{Kapitel~\ref{sec:comparison}} zeigte bereits \gls{GWT} als Alternative zu Kotlin, aber es gibt durchaus noch eine ganze Reihe weiterer Optionen welche näher betrachtet werden könnten. Zum einen wäre da die Möglichkeit mithilfe von Node.js \cite{nodeJs} auch mit JavaScript Serveranwendungen zu programmieren. Zum anderen gibt es noch alternativ die Programmiersprache Dart \cite{dart}, welche von Google entwickelt wird. Mit dieser Sprachen sollen sich Client-, Server- und Mobil-Anwendungen erstellen lassen. Da sich die genannten Alternativen ebenso wie Kotlin für die Programmierung von Server-Client-Anwendungen verwenden lassen, stellen diese genau wie \gls{GWT} einen sinnvollen Vergleich dar.\\
\\
Eine weitere Programmiersprache welche sich als Vergleichspartner anbietet ist TypeScript \cite{typeScript}. Diese erfreut sich laut den Indizes \cite{tiobeIndex}, \cite{redMonkIndex} und \cite{pyplIndex} ebenfalls sehr großer Beliebtheit. Sie ist dabei in zwei aus drei Fälle vor Kotlin. Anders als Kotlin ist sie aber für die clientseitige Programmierung ausgelegt, da im Fall von TypeScript nach JavaScript kompiliert wird. Allerdings ist dabei anzumerken das auch an dieser Stelle eine Verwendung von Node.js zur Erstellung von Server-Anwendungen benutzt werden kann.