% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Grundlagen}

\section{REST-API}
\gls{REST} ist ein von Roy Fielding entwickelter Architekturstil, welchen er in seiner Dissertation \cite{dissertationFielding} beschrieb. Dabei geht er ebenfalls auf eine Reihe von Leitsätzen und Praktiken ein, welche sich in System auf Basis von Netzwerken bewährt haben.\\
\\
Laut \cite[143]{apiDesign} unterstützt der REST Architekturstil eine Reihe von Protokollen, mit welchen solcher umgesetzt werden kann. Der bekannteste bzw. am häufigsten verwendete Vertreter ist dabei das Protokoll \gls{HTTP}. Es wird dabei \gls{REST} im Zusammenhang mit \gls{HTTP} als RESTful \gls{HTTP} bezeichnet. \\
\\
Da in dieser Arbeit die Webentwicklung im Vordergrund steht und \gls{HTTP} einer der wichtigsten Standards im Web ist, soll im nachfolgenden Verlauf \gls{REST} immer im Sinne von RESTful \gls{HTTP} verstanden werden.\\
\\
In den nachfolgenden Abschnitte soll die allgemeine Definition, die Vor- und Nachteile und die Qualitätsmerkmale einer \gls{API} näher beleuchtet werden. Anschließend wird auf die Grundprinzipien von \gls{REST} detaillierter eingegangen.

\subsection{Allgemeine Definition einer \gls{API}}\label{sec:defAPI}
Laut \cite[7]{apiDesign} definiert Kai Spichale eine \gls{API} mit den Worten von Joshua Bloch wie folgt: \enquote{Eine API spezifiziert die Operationen sowie die Ein- und Ausgaben einer Softwarekomponente. Ihr Hauptzweck besteht darin, eine Menge an Funktionen unabhängig von ihrer Implementierung zu definieren, sodass die Implementierung variieren kann, ohne die Benutzer der Softwarekomponente zu beeinträchtigen}. Des weiteren unterteilt dieser die \glspl{API} in zwei Kategorien ein, in Programmiersprachen- und Remote-\glspl{API}. Des weiteren definiert er die \glspl{API} der Programmiersprachen als abhängig und die Remote als unabhängig gegenüber der Sprache und der Plattform. \cite[7-8]{apiDesign} 

\subsection{Vorteile einer \gls{API}}
\subsubsection{Stabilität durch lose Kopplung}
Mithilfe von \glspl{API} soll die Abhängigkeit zum Benutzer minimiert werden, der dadurch nicht mehr stark an die Implementierung gekoppelt ist. Das ermöglicht eine Veränderung der eigentlichen Implementation einer Softwarekomponente, ohne das der Benutzer davon etwas bemerkt. (vgl. \cite[9]{apiDesign})

\subsubsection{Portabilität}
Es ist möglich für unterschiedliche Plattformen eine einheitliche Implementierung einer \gls{API} bereitzustellen, obwohl diese im inneren verschieden implementiert sind. Ein bekanntest Beispiel ist dabei die \gls{JRE}, welches diese Funktionalität für Java-Programme bereitstellt. (vgl. \cite[9]{apiDesign})

\subsubsection{Komplexitätsreduktion durch Modularisierung}
Der \gls{API}-Benutzer besitzt in erster Linie keine genauen Informationen über die Komplexität der Implementierung. Diese Tatsache folgt dem Geheimprinzip und soll der Beherrschung großer Projekte in Hinsicht ihrer Komplexität dienen. Zusätzlich bringt dieser Aspekt auch einen Wirtschaftlichen Vorteil, denn durch die Modularisierung ist eine bessere Arbeitsteilung möglich, was wiederum Entwicklungskosten sparen kann. (vgl. \cite[10]{apiDesign})

\subsubsection{Softwarewiederverwendung und Integration}
Neben dem verbergen von Details zur Implementierung sollten \glspl{API} Funktionen einer Komponente leicht verständlich bereitstellen, um \gls{API}-Nutzern eine einfache Integration bzw. Verwendung zu ermöglichen. Aus diesen sollten \glspl{API} auch dahingehend optimiert werden. (vgl. \cite[10]{apiDesign})

\subsection{Nachteile einer \gls{API}}
\subsubsection{Interoperabilität}
Ein Nachteil, der allerdings nur Programmiersprachen-\glspl{API} betrifft, ist die Interoperabilität zu anderen Programmiersprachen. Beispielsweise kann ein Programm, welches in Go geschrieben wurde, nicht auf die Java-\gls{API} zugreifen. Als Problemlösung stehen hierbei aber die Remote-\gls{API} bereit. Diese arbeiten mit Protokollen wie \gls{HTTP} oder \gls{AMQP}, welche sprach- und plattformunabhängig sind\footnote{\hyperref[sec:defAPI]{siehe Kapitel~\ref{sec:defAPI}}}.\cite[10]{apiDesign}

\subsubsection{Änderbarkeit}
Dadurch das geschlossene \gls{API}-Verträge mit den Benutzern nicht gebrochen werden sollten, kann es hinsichtlich der Änderbarkeit zu Problemen kommen. Das ist aber nur der Fall sofern die Benutzer nicht bekannt sind oder nicht kontrolliert werden können. In so einem Fall spricht man von veröffentlichten \glspl{API}. Als Gegenstück dazu können interne \glspl{API} betrachtet werden, denn bei diesen wäre eine Kontrolle der Benutzer möglich.

\subsection{Qualitätsmerkmale}\label{sec:qualityFeatures}
\subsubsection{Benutzbarkeit}
Als Zentrale Anforderung an einem guten Design für \gls{API} stehen die leichte Verständlichkeit, Erlernbarkeit und Benutzbarkeit für andere Nutzer. Um diese Anforderung umzusetzen haben sich ein Reihe von allgemeinen Eigenschaften/Zielen etabliert. \cite[13-14]{apiDesign} Eine Auflistung, inklusive einer kurzen Beschreibung der jeweiligen Eigenschaft, werden in der \hyperref[tab:APIUsabilityProperties]{Tabelle~\ref{tab:APIUsabilityProperties}} aufgeführt. Für detaillierte Informationen zu die einzelnen Eigenschaft, können diese in \cite[14-23]{apiDesign} nachgeschlagen werden.
\begin{table}
	\captionsetup{justification=centering}
	\caption{Eigenschaften/Ziele des Qualitätsmerkmals \enquote{Benutzbarkeit}\newline (verändert nach \cite[14-23]{apiDesign})}
	\label{tab:APIUsabilityProperties}
	\begin{tabu}{|p{0.25\textwidth}|p{0.7\textwidth}|}
		\hline
		\rowfont[c]{\bfseries}
		\taburowcolors 1{tableheadcolor .. tableheadcolor}
		Eigenschaft/Ziel & Beschreibung \\
		\hline
		\taburowcolors 2{tablebodycolor .. tablerowcolor}
		Konsistent & Gemeint ist damit das Entscheidungen hinsichtlich des Entwurfs einheitlich im Quellcode angewandt werden. Das betrifft beispielsweise die Namensgebung von Variablen oder Funktionen. \\
		Intuitiv verständlich & Für diese Ziel ist eine Konsistente \gls{API} unter Verwendung von Namenskonventionen unabdingbar. Grundlegend kann dabei gesagt werden das gleiche Dinge einheitliche Namen, aber auch ungleiche Dinge unterschiedliche Namen haben sollten. So können bereits durch bekannte Funktionen Rückschlüsse auf andere unbekannte gezogen werden. Ein konkretes Beispiel dafür sind die \textit{getter}- und \textit{setter}-Methoden in der Java-Welt.\\
		Dokumentiert & Eine ausführliche Dokumentation mit Beschreibungen zu den einzelnen Klassen, Methoden und Parametern, ist für eine einfache Benutzung dringend erforderlich. Zusätzlich sollten Beispiele die Erläuterungen unterstreichen. \\
		Einprägsam und leicht zu lernen & Damit eine \gls{API} einfach zu erlernen ist, sind die ersten drei Punkte dieser Tabelle unabdingbar. Wichtig ist die Einstiegshürden gering zu halten, um potenzielle Nutzer nicht abzuschrecken. Prinzipiell ist es von Vorteil wenn mit relativ wenig Code erste Ergebnisse erzielt werden können.\\
		Lesbaren Code fördern & Eine \gls{API} kann großen Einfluss auf die Lesbarkeit des Client-Codes haben und diesen so signifikant verbessern. Durch eine gute Lesbarkeit können zum Beispiel besser bzw. schneller Fehler entdeckt werden. Um den Client-Code möglichst schmal zu halt sollte die \gls{API} Hilfsmethoden anbieten, wobei gilt das der Client nichts tun müssen sollte was ihm durch die \gls{API} abgenommen werden könnte.\\
		Schwer falsch zu benutzen & Unerwartetes Verhalten aus Sicht den Nutzers sollte vermieden werden, um unerwartete Fehler zu vermeiden und um die \gls{API} intuitiv zu halten.\\
		Minimal & Prinzipiell gilt es eine \gls{API} so klein wie möglich zu halten und Funktionen welche nicht unbedingt benötigt werden im zweifel weg zu lassen. Denn nachträglich können solche Elemente nicht mehr trivial entfernt werden. Außerdem lässt sich sagen das je größer die \gls{API} desto größer die Komplexität. \\
		Stabil & Durch Stabilität wird sicher gestellt das Änderungen keine Auswirkung auf alte Benutzer hat. Wenn auftretende negative Auswirkungen unvermeidbar sind, sollten diese entweder ausführlich kommuniziert oder eine neue Version benutzt werden. \\
		Einfach erweiterbar & Für die Erweiterbarkeit einer \gls{API} ist der Aufwand von Änderungen von Clients zu beachten. Wenn der Client nach einer Erweiterung nicht angepasst werden muss, ist dabei der Idealfall. Durch Vererbung kann beispielsweise so ein Verhalten erreicht werden. \\
		\hline
	\end{tabu}
\end{table}

\subsubsection{Effizienz}
Unter dem Qualitätsmerkmal Effizienz kann zum Beispiel der geringe Verbrauch von Akku oder dem Datenvolumen bei Mobilen Geräten verstanden werden. Oder aber die Skalierbarkeit einer \gls{API}, welches bei einem großen Zuwachs von Aufrufen durchaus entscheidend sein kann. \cite[13]{apiDesign}

\subsubsection{Zuverlässigkeit}
Unter der Zuverlässigkeit einer \gls{API} kann die Fehleranfälligkeit verstanden werden bzw. wie gut diese auf Fehler reagieren kann. Ein wichtiger Aspekt der dabei auf jeden Fall beachtet werden sollte ist die Rückgabe von standardisierten HTTP-Statuscodes. Dies ermöglicht dem Benutzer ein ordentliches Feedback, welches noch durch konkretisierte Fehlermeldungen verdeutlicht werden sollte. \cite[13,189]{apiDesign}

\subsection{Grundprinzipien von REST}
\subsubsection{Eindeutige Identifikation von Ressourcen}
Für jede Ressourcen muss eine eindeutige Identifikation definiert werden. Im Web stehen dabei \glspl{URI} für diesen Zweck bereit. Die Wichtigkeit dieses Prinzips liegt nahe. Wenn beispielsweise Produkte von einem Online-Shop nicht eindeutig identifiziert werden könnten, dann wäre das zum Beispiel für Werbezweck mehr als unpraktisch. E-Mails mit personalisierter Werbung für Produkte wäre ohne eine eindeutige Identifikation dieser nicht bzw. sehr umständlich möglich.\\
\\
Wichtig ist zu beachten das mit \glspl{URI} nicht nur einzelne Ressourcen identifiziert, sondern auch Ressourcenlisten werden können. Um bei dem Beispiel von oben zu bleiben, könnte es eine \gls{URI} geben mit welcher ein einzelnes Produkt und eine mit welcher eine Liste von Produkten identifiziert wird. Dies ist kein Widerspruch gegen das Prinzip, welches besagt das jede Ressource eindeutig identifiziert werden muss, sondern in diesem Fall gilt eine Liste als selbstständige Ressource.

\subsubsection{Verwendung von Hypermedia}
Hypermedia als Begriff ist Zusammensetzung aus den Begriffen \textit{Hypertest} und \textit{Multimedia}. Dabei kann \textit{Hypermedia} als Oberbegriff von \textit{Hypertext} betrachtet werden, denn \textit{Hypermedia} unterstützt nicht nur Texte, sondern auch andere Multimediale Inhalte wie zum Beispiel Dokumente, Bilder, Videos oder Links. Letzteres kann für das Ausführen von Funktionen oder zum Navigieren innerhalb des Browsers verwendet werden und ist ein bekanntes Element in der \gls{HTML}. Daher kann \gls{HTML} auch als klassischer Vertreter von Hypermediaformaten betrachtet werden. Damit ein Client weiß welche Aktionen bzw. welchen Pfaden folgen kann, werden ihm diese vom Server mithilfe von Hypermedia zur Verfügung gestellt.

\subsubsection{Verwendung von HTTP-Standardmethoden}
Um die vom Server bereit gestellten Links ordnungsgemäß auszuführen, müssen neben den \glspl{URI} auch einheitliche Schnittstellen bekannt sein. Das setzt voraus, dass alle Clients über Verwendung und Semantik der Schnittstellen Bescheid wissen. An dieser Stelle kommen die \gls{HTTP}-Standardmethoden zum Einsatz. Die Schnittstellen von \gls{HTTP} bestehen dabei im wesentlichen aus den Funktionen \textit{GET}, \textit{HEAD}, \textit{POST}, \textit{PUT} und \textit{DELETE}, welche alle in der \gls{HTTP}-Spezifikation\footnote{siehe \cite{httpSpecification}} definiert sind. Die Methoden \textit{PATCH} oder auch \textit{LINK} waren dabei nicht von Anfang in der Spezifikation enthalten, sonder wurden erst in nachträglich hinzugefügt.\\
\\
Ein Client kann mithilfe der Methode \textit{GET}, ohne genaues Wissen der Ressource, eine Repräsentation dieser abfragen, denn diese allgemeinen Schnittstellen werden für jede Ressource verwendet. Durch diese mögliche Vorhersagbarkeit sind die Qualitätsmerkmale aus den \hyperref[sec:qualityFeatures]{Kapiteln~\ref{sec:qualityFeatures}} erfüllt. Zusätzlich ist noch anzumerken das durch Benutzung der Methode \textit{GET} keine unerwünschten Effekte befürchtet werden müssen, denn diese ist idempotent. Einfach ausgedrückt kann ein lesender Zugriff auf eine Ressource keine Änderung des Zustands hervorrufen.

\subsubsection{Unterschiedliche Repräsentationen von Ressourcen}
Um mit den Daten, welcher eine \gls{API} zurückgibt, umzugehen muss der Client wissen in welchem Format er die Daten zurückbekommen möchte. Dazu muss er das gewünschte Format mithilfe von \gls{HTTP} Content Negotiation von der \gls{API} abzufragen. Dabei besteht die Möglichkeit mehrere gewünschte Formate, mit unterschiedlicher Priorität, anzugeben. Der Server gibt anschließend das Format zurück, welches Kompatibel und die Höchste Priorität besitzt. Die gängigste Methode ist dabei die gewünschten Formate im \textit{Accept-Header} des Requestes mitzusenden.

\subsubsection{Statuslose Kommunikation}
Das letzte Grundprinzip besagt das es keinen Sitzungsstatus, welcher auf dem Server über mehrere Anfragen gehalten wird, geben darf. Der Kommunikationsstatus muss demzufolge in der Ressource selber oder im Client gespeichert werden. Durch die Statuslose Kommunikation wird die Kopplung zwischen Server und Client verringert. Das wiederum bringt den Vorteil das beispielsweise ein Neustart des Servers den Client nicht stören oder sogar zum Absturz bringen kann, denn dieser würde es gar nicht erst mitbekommen. Ein weiterer nicht unerheblicher Vorteil welcher daraus resultiert ist die Möglichkeit der Lastenverteilung auf unterschiedliche Serverinstanzen.

\subsection{HATEOAS}
\enquote{Hypermedia As The Engine Of Application State} oder kurz HATEOAS ist ein Design-Konzept, welches von vielen \glspl{API} die sich selber als \gls{REST}ful bezeichnen missachtet wird. Diesen Begriff bzw. diese Aussage kann nach Kai Spichale mit nachfolgenden Bedeutungen beschrieben werden \cite[156]{apiDesign}:
\begin{itemize}
	\item \enquote{»Hypermedia« ist eine Verallgemeinerung des Hypertexts mit multimedialen Anteilen. Beziehungen zwischen Objekten werden durch
		Hypermedia Controls abgebildet.}
	\item \enquote{Mit »Engine« ist ein Zustandsautomat gemeint. Die Zustände und
		Zustandsübergänge der »Engine« beschreiben das Verhalten der
		»Application«.}
	\item \enquote{Im Kontext von REST kann man »Application« mit Ressource
		gleichsetzen.}
	\item \enquote{Mit »State« ist der Zustand der Ressource gemeint, deren Zustandsübergänge durch die »Engine« definiert werden.}
\end{itemize}
Grundgedanke hinter diesen Konzept ist die Selbstbeschreibung einer \gls{API}. Das Ziel soll dabei sein, dass Clients nicht genau über die \gls{API} Bescheid wissen müssen, sondern die Ressource dem Client zeigt wie er durch die \gls{API} navigieren kann. Als Resultat des ganzen benötigt der Client nur das Wissen über die \gls{URL} des Einstiegs, alles weitere bekommt er vom Server in Form von Links mitgeteilt. \\
\\
Durch das Konzept HATEOAS wird ein dynamischer Workflow erzeugt, wodurch die Ressource volle Kontrolle über die \gls{API} bekommt. Damit ist es beispielsweise möglich anhand von Clients unterschiedliche Links bzw. Navigationspunkte auszuliefern oder Links auszutauschen ohne das der Client davon etwas bemerkt. Um diese Vorteile zu nutzen ist es natürlich notwendig die bereitgestellten Links zu verwenden.

%\section{Design-Patterns}

\section{Das Build-Tool Gradle}
Gradle ist ein Open-Source Build-Tool, welches in erster Linie für die Java-Welt entwickelt wurde, aber mittlerweile auch andere Sprachen wie zum Beispiel Kotlin unterstützt. Es basiert auf den Erfahrungen von anderen großen Build-Tools wie Ant und Maven und hat damit große Akzeptanz gefunden. Indiz dafür ist der Wechsel zu Gradle von einigen großen und bekannten Projekten, wie zum Beispiel Android oder dem Spring Framework.\\
\\
Die in diesem Kapitel behandelten Fakten und Erklärungen entstammen aus dem Buch \enquote{Introducing Gradle} von Balaji Varanasi und Sudha Belida. (vgl. \cite{introducingGradle})

\subsection{Eigenschaften von Gradle}
\subsubsection{Declarative Dependency Management}
Gradle biete eine komfortable Möglichkeit mit Abhängigkeiten umzugehen. Denn viele Projekte verwenden andere Bibliotheken oder Frameworks, welche gegebenenfalls eigenen Abhängigkeiten aufweisen. Dadurch kann es sehr mühselig werden die ganze Abhängigkeitsstruktur mit alle Versionen zu verwalten. Es müssen nur die benötigten Abhängigkeiten definiert werden und Gradle kümmert sich um den Download dieser, inklusive aller Unterabhängigkeiten. Es ist wichtig zu wissen das Gradle nur das \textit{Was} aber nicht das \textit{Wie} gesagt werden muss.

\subsubsection{Declarative Builds}
Damit Skripte für den Build-Prozess einfach und verständlich sind, verwendet Gradle dafür eine \gls{DSL} auf Basis der Programmiersprache Groovy. Dadurch werden eine Reihe von Sprach-Elementen bereitgestellt, welche einfach zusammengestellt werden können und ihre Absicht klar zum Ausdruck bringen.

\subsubsection{Build by Convention}
Um den Konfigurationsaufwand von Projekten zu minimieren bietet Gradle eine Reihe von Standardwerten und Konventionen an. Durch die Einhaltung dieser werden Build-Skripte sehr prägnant, sie sind aber dennoch nicht daran gebunden. Da die Skripte auf Groovy basieren können die Konventionen leicht, durch schreiben von Groovy-Code, umgangen werden.

\subsubsection{Incremental Builds}
In größeren Projekten kommt es oft zu sehr langsame Build-Zeiten, weil andere Tools im Gegensatz zu Gradle versuchen den Code immer zu säubern und neu aufzubauen. Durch die inkrementellen Builds, welche Gradle bereitstellt, kann dieses Problem umgangen werden. Tasks die der Build-Prozess ausführt, werden sofern keine Änderungen festgestellt wurden übersprungen. Dafür wird überprüft ob sich die Ein- oder Ausgänge geändert haben.

\subsubsection{Gradle Wrapper}
Mithilfe dieses Features ist es möglich das Projekt zu bauen obwohl keine Installation von Gradle vorhanden ist. Der Gradle Wrapper stellt dafür eine Batch-Datei für Windows- und ein Shell-Skript für Linux- bzw. Mac-Umgebungen bereit. Ein weiterer Vorteil ist die Erstellung neuer \gls{CI} Server, welche die Build-Prozesse somit ohne zusätzliche Konfiguration ausführen können.

\subsubsection{Plugins}
Mithilfe von Plugins bzw. Erweiterungen können die Funktionalitäten von Gradle beliebig erweitert oder angepasst werden. Dabei dienen die sie als Kappselung von Build- oder Task-Logik und können bequem verteilt bzw. in anderen Projekten wieder verwendet werden. Somit ist beispielsweise eine Unterstützung einer zusätzlichen Programmiersprache ohne weitere möglich.

\section{Schachnotationen FEN und SAN}

\section{Schachregeln}