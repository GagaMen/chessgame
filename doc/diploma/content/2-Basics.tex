% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Grundlagen}

\section{REST-API}
\gls{REST} ist ein von Roy Fielding entwickelter Architekturstil, welchen er in seiner Dissertation \cite{dissertationFielding} beschrieb. Dabei geht er ebenfalls auf eine Reihe von Leitsätzen und Praktiken ein, welche sich in System auf Basis von Netzwerken bewährt haben.\\
\\
Laut \cite[143]{apiDesign} unterstützt der REST Architekturstil eine Reihe von Protokollen, mit welchen solcher umgesetzt werden kann. Der bekannteste bzw. am häufigsten verwendete Vertreter ist dabei das Protokoll \gls{HTTP}. Es wird dabei \gls{REST} im Zusammenhang mit \gls{HTTP} als RESTful \gls{HTTP} bezeichnet. \\
\\
Da in dieser Arbeit die Webentwicklung im Vordergrund steht und \gls{HTTP} einer der wichtigsten Standards im Web ist, soll im nachfolgenden Verlauf \gls{REST} immer im Sinne von RESTful \gls{HTTP} verstanden werden.\\
\\
In den nachfolgenden Abschnitte soll die allgemeine Definition, die Vor- und Nachteile und die Qualitätsmerkmale einer \gls{API} näher beleuchtet werden. Anschließend wird auf die Grundprinzipien von \gls{REST} detaillierter eingegangen.

\subsection{Allgemeine Definition einer \gls{API}}\label{sec:defAPI}
Laut \cite[7]{apiDesign} definiert Kai Spichale eine \gls{API} mit den Worten von Joshua Bloch wie folgt: \enquote{Eine API spezifiziert die Operationen sowie die Ein- und Ausgaben einer Softwarekomponente. Ihr Hauptzweck besteht darin, eine Menge an Funktionen unabhängig von ihrer Implementierung zu definieren, sodass die Implementierung variieren kann, ohne die Benutzer der Softwarekomponente zu beeinträchtigen}. Des weiteren unterteilt dieser die \glspl{API} in zwei Kategorien ein, in Programmiersprachen- und Remote-\glspl{API}. Des weiteren definiert er die \glspl{API} der Programmiersprachen als abhängig und die Remote als unabhängig gegenüber der Sprache und der Plattform. \cite[7-8]{apiDesign} 

\subsection{Vorteile einer \gls{API}}
\subsubsection{Stabilität durch lose Kopplung}
Mithilfe von \glspl{API} soll die Abhängigkeit zum Benutzer minimiert werden, der dadurch nicht mehr stark an die Implementierung gekoppelt ist. Das ermöglicht eine Veränderung der eigentlichen Implementation einer Softwarekomponente, ohne das der Benutzer davon etwas bemerkt. (vgl. \cite[9]{apiDesign})

\subsubsection{Portabilität}
Es ist möglich für unterschiedliche Plattformen eine einheitliche Implementierung einer \gls{API} bereitzustellen, obwohl diese im inneren verschieden implementiert sind. Ein bekanntest Beispiel ist dabei die \gls{JRE}, welches diese Funktionalität für Java-Programme bereitstellt. (vgl. \cite[9]{apiDesign})

\subsubsection{Komplexitätsreduktion durch Modularisierung}
Der \gls{API}-Benutzer besitzt in erster Linie keine genauen Informationen über die Komplexität der Implementierung. Diese Tatsache folgt dem Geheimprinzip und soll der Beherrschung großer Projekte in Hinsicht ihrer Komplexität dienen. Zusätzlich bringt dieser Aspekt auch einen Wirtschaftlichen Vorteil, denn durch die Modularisierung ist eine bessere Arbeitsteilung möglich, was wiederum Entwicklungskosten sparen kann. (vgl. \cite[10]{apiDesign})

\subsubsection{Softwarewiederverwendung und Integration}
Neben dem verbergen von Details zur Implementierung sollten \glspl{API} Funktionen einer Komponente leicht verständlich bereitstellen, um \gls{API}-Nutzern eine einfache Integration bzw. Verwendung zu ermöglichen. Aus diesen sollten \glspl{API} auch dahingehend optimiert werden. (vgl. \cite[10]{apiDesign})

\subsection{Nachteile einer \gls{API}}
\subsubsection{Interoperabilität}
Ein Nachteil, der allerdings nur Programmiersprachen-\glspl{API} betrifft, ist die Interoperabilität zu anderen Programmiersprachen. Beispielsweise kann ein Programm, welches in Go geschrieben wurde, nicht auf die Java-\gls{API} zugreifen. Als Problemlösung stehen hierbei aber die Remote-\gls{API} bereit. Diese arbeiten mit Protokollen wie \gls{HTTP} oder \gls{AMQP}, welche sprach- und plattformunabhängig sind\footnote{\hyperref[sec:defAPI]{siehe Kapitel~\ref{sec:defAPI}}}.\cite[10]{apiDesign}

\subsubsection{Änderbarkeit}
Dadurch das geschlossene \gls{API}-Verträge mit den Benutzern nicht gebrochen werden sollten, kann es hinsichtlich der Änderbarkeit zu Problemen kommen. Das ist aber nur der Fall sofern die Benutzer nicht bekannt sind oder nicht kontrolliert werden können. In so einem Fall spricht man von veröffentlichten \glspl{API}. Als Gegenstück dazu können interne \glspl{API} betrachtet werden, denn bei diesen wäre eine Kontrolle der Benutzer möglich.

\subsection{Qualitätsmerkmale }
\subsubsection{Benutzbarkeit}
Als Zentrale Anforderung an einem guten Design für \gls{API} stehen die leichte Verständlichkeit, Erlernbarkeit und Benutzbarkeit für andere Nutzer. Um diese Anforderung umzusetzen haben sich ein Reihe von allgemeinen Eigenschaften/Zielen etabliert. \cite[13-14]{apiDesign} Eine Auflistung, inklusive einer kurzen Beschreibung der jeweiligen Eigenschaft, werden in der \hyperref[tab:APIUsabilityProperties]{Tabelle~\ref{tab:APIUsabilityProperties}} aufgeführt. Für detaillierte Informationen zu die einzelnen Eigenschaft, können diese in \cite[14-23]{apiDesign} nachgeschlagen werden.
\begin{table}
	\captionsetup{justification=centering}
	\caption{Eigenschaften/Ziele des Qualitätsmerkmals \enquote{Benutzbarkeit}\newline (verändert nach \cite[14-23]{apiDesign})}
	\label{tab:APIUsabilityProperties}
	\begin{tabu}{|p{0.25\textwidth}|p{0.7\textwidth}|}
		\hline
		\rowfont[c]{\bfseries}
		\taburowcolors 1{tableheadcolor .. tableheadcolor}
		Eigenschaft/Ziel & Beschreibung \\
		\hline
		\taburowcolors 2{tablebodycolor .. tablerowcolor}
		Konsistent & Gemeint ist damit das Entscheidungen hinsichtlich des Entwurfs einheitlich im Quellcode angewandt werden. Das betrifft beispielsweise die Namensgebung von Variablen oder Funktionen. \\
		Intuitiv verständlich & Für diese Ziel ist eine Konsistente \gls{API} unter Verwendung von Namenskonventionen unabdingbar. Grundlegend kann dabei gesagt werden das gleiche Dinge einheitliche Namen, aber auch ungleiche Dinge unterschiedliche Namen haben sollten. So können bereits durch bekannte Funktionen Rückschlüsse auf andere unbekannte gezogen werden. Ein konkretes Beispiel dafür sind die \textit{getter}- und \textit{setter}-Methoden in der Java-Welt.\\
		Dokumentiert & Eine ausführliche Dokumentation mit Beschreibungen zu den einzelnen Klassen, Methoden und Parametern, ist für eine einfache Benutzung dringend erforderlich. Zusätzlich sollten Beispiele die Erläuterungen unterstreichen. \\
		Einprägsam und leicht zu lernen & Damit eine \gls{API} einfach zu erlernen ist, sind die ersten drei Punkte dieser Tabelle unabdingbar. Wichtig ist die Einstiegshürden gering zu halten, um potenzielle Nutzer nicht abzuschrecken. Prinzipiell ist es von Vorteil wenn mit relativ wenig Code erste Ergebnisse erzielt werden können.\\
		Lesbaren Code fördern & Eine \gls{API} kann großen Einfluss auf die Lesbarkeit des Client-Codes haben und diesen so signifikant verbessern. Durch eine gute Lesbarkeit können zum Beispiel besser bzw. schneller Fehler entdeckt werden. Um den Client-Code möglichst schmal zu halt sollte die \gls{API} Hilfsmethoden anbieten, wobei gilt das der Client nichts tun müssen sollte was ihm durch die \gls{API} abgenommen werden könnte.\\
		Schwer falsch zu benutzen & Unerwartetes Verhalten aus Sicht den Nutzers sollte vermieden werden, um unerwartete Fehler zu vermeiden und um die \gls{API} intuitiv zu halten.\\
		Minimal & Prinzipiell gilt es eine \gls{API} so klein wie möglich zu halten und Funktionen welche nicht unbedingt benötigt werden im zweifel weg zu lassen. Denn nachträglich können solche Elemente nicht mehr trivial entfernt werden. Außerdem lässt sich sagen das je größer die \gls{API} desto größer die Komplexität. \\
		Stabil & Durch Stabilität wird sicher gestellt das Änderungen keine Auswirkung auf alte Benutzer hat. Wenn auftretende negative Auswirkungen unvermeidbar sind, sollten diese entweder ausführlich kommuniziert oder eine neue Version benutzt werden. \\
		Einfach erweiterbar & Für die Erweiterbarkeit einer \gls{API} ist der Aufwand von Änderungen von Clients zu beachten. Wenn der Client nach einer Erweiterung nicht angepasst werden muss, ist dabei der Idealfall. Durch Vererbung kann beispielsweise so ein Verhalten erreicht werden. \\
		\hline
	\end{tabu}
\end{table}

\subsubsection{Effizienz}
Unter dem Qualitätsmerkmal Effizienz kann zum Beispiel der geringe Verbrauch von Akku oder dem Datenvolumen bei Mobilen Geräten verstanden werden. Oder aber die Skalierbarkeit einer \gls{API}, welches bei einem großen Zuwachs von Aufrufen durchaus entscheidend sein kann. \cite[13]{apiDesign}

\subsubsection{Zuverlässigkeit}
Unter der Zuverlässigkeit einer \gls{API} kann die Fehleranfälligkeit verstanden werden bzw. wie gut diese auf Fehler reagieren kann. Ein wichtiger Aspekt der dabei auf jeden Fall beachtet werden sollte ist die Rückgabe von standardisierten HTTP-Statuscodes. Dies ermöglicht dem Benutzer ein ordentliches Feedback, welches noch durch konkretisierte Fehlermeldungen verdeutlicht werden sollte. \cite[13,189]{apiDesign}

\subsection{Grundprinzipien von REST}

%\section{Design-Patterns}

\section{Das Build-Tool Gradle}

\section{Schachnotationen FEN und SAN}

\section{Schachregeln}