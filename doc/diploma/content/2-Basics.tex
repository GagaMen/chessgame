% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Grundlagen}
In diesem Kapitel sollen die Grundlagen, welche zum besseren Verständnis dieser Arbeit notwendig sind, behandelt werden. Dabei dient der erste Abschnitt zur Erläuterung von \glspl{API}, welche den \gls{REST} Architekturstil befolgen. Der zweite Abschnitt dient zur näheren Betrachtung des Build-Tools Gradle, welches für die Umsetzung des Praktischen Teils dieser Arbeit verwendet werden soll. Eine genauere Betrachtung der Schachnotationen \gls{FEN} und \gls{SAN} sollen Inhalt des dritten Abschnittes sein. Da als Veranschaulichung dieser Arbeit das Brettspiel \enquote{Schach} dienen soll, dient das letzte Kapitel zur kurz Einführung in die Schachregeln.

\section{REST-API}
\gls{REST} ist ein von Roy Fielding entwickelter Architekturstil, welchen er in seiner Dissertation \cite{dissertationFielding} erstmals beschrieb. Dabei geht er ebenfalls auf eine Reihe von Leitsätzen und Praktiken ein, welche sich in Systemen auf Basis von Netzwerken bewährt haben.\\
\\
Laut \cite[143]{apiDesign} unterstützt der \gls{REST} Architekturstil eine Reihe von Protokollen, mit welchen solcher umgesetzt werden kann. Der bekannteste bzw. am häufigsten verwendete Vertreter ist dabei das \gls{HTTP}. Es wird dabei im Zusammenhang mit \gls{REST} als \gls{REST}ful \gls{HTTP} bezeichnet. \\
\\
Da in dieser Arbeit die Webentwicklung im Vordergrund steht und \gls{HTTP} einer der wichtigsten Standards im Web ist, soll im nachfolgenden Verlauf der Arbeit \gls{REST} immer im Sinne von RESTful \gls{HTTP} verstanden werden.\\
\\
In den nachfolgenden Abschnitten soll die allgemeine Definition, die Vor- und Nachteile und die Qualitätsmerkmale einer \gls{API} näher beleuchtet werden. Anschließend wird auf die Grundprinzipien von \gls{REST} detaillierter eingegangen. Als letztes wird das Konzept HATEOAS genauer erläutert, welches laut Roy Fielding ein Muss \cite{restMustBeHypertextDriven} für jede RESTful \gls{API} ist.\\
\\
Als Grundlage der nachfolgenden Unterkapitel dient das Buch \enquote{API-Design} \cite[7-10, 13-14, 144-148, 189]{apiDesign} von Kai Spichale.

\subsection{Allgemeine Definition einer API}\label{sec:defAPI}
Laut \cite[7]{apiDesign} definiert Kai Spichale eine \gls{API} mit den Worten von Joshua Bloch wie folgt: \enquote{Eine API spezifiziert die Operationen sowie die Ein- und Ausgaben einer Softwarekomponente. Ihr Hauptzweck besteht darin, eine Menge an Funktionen unabhängig von ihrer Implementierung zu definieren, sodass die Implementierung variieren kann, ohne die Benutzer der Softwarekomponente zu beeinträchtigen}. Des Weiteren unterteilt dieser die \glspl{API} in die zwei Kategorien Programmiersprachen- und Remote-\glspl{API} ein, wobei erstere abhängig und letztere unabhängig gegenüber Sprache und Plattform sind.

\subsection{Vorteile einer API}
\subsubsection{Stabilität durch lose Kopplung}
Mithilfe von \glspl{API} sollen die Abhängigkeiten zum Benutzer minimiert werden. Dadurch wird eine schwächere Kopplung an die Implementierung erreicht. Das ermöglicht eine Veränderung der eigentlichen Implementation einer Softwarekomponente, ohne das der Benutzer davon etwas bemerken muss.

\subsubsection{Portabilität}
Es ist möglich für unterschiedliche Plattformen eine einheitliche Implementierung einer \gls{API} bereitzustellen, obwohl diese im inneren unterschiedlich implementiert sind. Ein bekanntest Beispiel ist dabei die \gls{JRE}, welches diese Funktionalität für Java-Programme bereitstellt.

\subsubsection{Komplexitätsreduktion durch Modularisierung}
Der \gls{API}-Benutzer besitzt in erster Linie keine genauen Informationen über die Komplexität der Implementierung. Diese Tatsache folgt dem Geheimprinzip und soll der Beherrschung großer Projekte in Hinsicht ihrer Komplexität dienen. Zusätzlich bringt dieser Aspekt auch einen Wirtschaftlichen Vorteil, denn durch die Modularisierung ist eine bessere Arbeitsteilung möglich. Das wiederum kann Entwicklungskosten sparen.

\subsubsection{Softwarewiederverwendung und Integration}
Neben dem verbergen von Details zur Implementierung sollten die Funktionen einer Softwarekomponente, durch die \gls{API}, leicht verständlich bereitgestellt werden. Dies ermöglicht den \gls{API}-Nutzern eine vereinfachte Verwendung bzw. Integration der \gls{API}, weshalb diese auch dahingehend optimiert werden sollte.

\subsection{Nachteile einer API}
\subsubsection{Interoperabilität}
Ein Nachteil, der allerdings nur Programmiersprachen-\glspl{API} betrifft, ist die Interoperabilität zu anderen Programmiersprachen. Beispielsweise kann ein Programm, welches in der Programmiersprache \enquote{Go} geschrieben wurde, nicht auf die Java-\gls{API} zugreifen. Als Problemlösung stehen hierbei aber die Remote-\gls{API} bereit. Diese arbeiten mit Protokollen wie \gls{HTTP} oder \gls{AMQP}, welche sprach- und plattformunabhängig sind\footnote{siehe \hyperref[sec:defAPI]{Kapitel~\ref{sec:defAPI}}}.

\subsubsection{Änderbarkeit}
Dadurch das geschlossene \gls{API}-Verträge mit den Benutzern nicht gebrochen werden sollten, kann es hinsichtlich der Änderbarkeit zu Problemen kommen. Das ist aber nur der Fall sofern die Benutzer nicht bekannt oder kontrollierbar sind. In so einem Fall spricht man von veröffentlichten \glspl{API}. Als Gegenstück dazu können interne \glspl{API} betrachtet werden. Diese haben eine wesentlich beschränktere Benutzerzahl, wodurch eine Kontrolle dieser eher möglich ist.

\subsection{Qualitätsmerkmale}\label{sec:qualityFeatures}
\subsubsection{Benutzbarkeit}
Als Zentrale Anforderungen an einem guten Design für \glspl{API} stehen die leichte Verständlichkeit, Erlernbarkeit und Benutzbarkeit für \gls{API}-Benutzer. Um diese Anforderung umzusetzen haben sich ein Reihe von allgemeinen Eigenschaften bzw. Zielen etabliert. Eine Auflistung, inklusive einer kurzen Beschreibung der jeweiligen Eigenschaft/Zielen, werden in der \hyperref[tab:APIUsabilityProperties]{Tabelle~\ref{tab:APIUsabilityProperties}} aufgeführt. Detaillierte Informationen dieser können in den Buch \cite[14-23]{apiDesign} nachgeschlagen werden.
{
\small\renewcommand{\arraystretch}{1.4}
\begin{longtabu} to \textwidth{X[1,L]X[3,L]}
	\captionabove{Eigenschaften/Ziele des Qualitätsmerkmals \enquote{Benutzbarkeit}\newline (verändert nach \cite[14-23]{apiDesign})} \\
	\hline
	\taburowcolors 1{tableheadcolor .. tableheadcolor}
	\bfseries Eigenschaft/Ziel &
	\bfseries Beschreibung \\\hline
	\endfirsthead
	\hline
	Eigenschaft/Ziel &
	Beschreibung \\ \hline
	\endhead
	\hline
	\taburowcolors 1{white .. white}
	\multicolumn{2}{r}{\emph{weiter auf der nächsten Seite \ldots}}
	\endfoot
	\hline
	\endlastfoot
	\taburowcolors 2{tablebodycolor .. tablerowcolor}
	Konsistent & Damit ist gemeint, dass Entscheidungen hinsichtlich des Entwurfs einheitlich im Quellcode angewandt werden. Das betrifft beispielsweise die Namensgebung von Variablen oder Funktionen.\\
	Intuitiv verständlich & Für dieses Ziel ist eine Konsistente \gls{API} unter Verwendung von Namenskonventionen unabdingbar. Grundlegend kann dabei gesagt werden das gleiche Dinge einheitliche Namen, aber auch ungleiche Dinge unterschiedliche Namen haben sollten. So können bereits durch bekannte Funktionen Rückschlüsse auf andere noch unbekannte gezogen werden. Ein konkretes Beispiel dafür sind \code{get}- und \code{set}-Methoden in der Java-Welt.\\
	Dokumentiert & Eine ausführliche Dokumentation mit Beschreibungen zu den einzelnen Klassen, Methoden und Parametern, ist für eine einfache Benutzung dringend erforderlich. Zusätzlich sollten Beispiele diese Erläuterungen unterstreichen.\\
	Einprägsam und leicht zu lernen & Damit eine \gls{API} einfach zu erlernen ist, sollten die ersten drei Punkte dieser Tabelle dringend erfüllt werden. Wichtig ist dabei eine geringe  Einstiegshürde, um potenzielle Nutzer nicht abzuschrecken. Prinzipiell ist es dabei immer sehr von Vorteil, wenn mit relativ wenig Code erste sichtbare Ergebnisse erzielt werden können.\\
	Lesbaren Code fördern & Eine \gls{API} kann großen Einfluss auf die Lesbarkeit des Client-Codes haben und diesen so signifikant verbessern. Durch eine gute Lesbarkeit können zum Beispiel besser bzw. schneller Fehler entdeckt werden. Um einen möglichst schmalen Client-Code zu fördern, sollten \glspl{API} benötigte Hilfsmethoden bereitstellen, sofern dies möglich ist. Als Prämisse kann dabei angesehen werden, dass die \gls{API} alle Funktionen bereitstellen sollte, welche sie dem Client auch abnehmen kann.\\
	Schwer falsch zu benutzen & Unerwartetes Verhalten aus Sicht den Nutzers sollte vermieden werden, um unerwartete Fehler zu verhindern und um die \gls{API} intuitiv bedienbar zu halten.\\
	Minimal & Prinzipiell gilt es eine \gls{API} so klein wie möglich zu halten und Funktionen welche nicht unbedingt benötigt werden im zweifel weg zu lassen. Denn nachträglich können solche Elemente nicht mehr mit trivialen Aufwand entfernt werden. Außerdem lässt sich sagen das je größer die \gls{API}, desto größer die Komplexität.\\
	Stabil & Durch Stabilität soll sichergestellt werden das Änderungen keine Auswirkung auf die Benutzer hat, welche eine ältere Version benutzen. Sind auftretende negative Auswirkungen unvermeidbar, sollten diese entweder ausführlich kommuniziert oder durch eine neue Version gekapselt werden.\\
	Einfach erweiterbar & Um den Aufwand der Erweiterung einer \gls{API} möglichst einfach zu halten, muss die Anpassung von bestehenden Clients berücksichtigt werden. Der Idealfall ist dabei, wenn Client von Änderungen unberührt bleiben. Ein solches Verhalten kann beispielsweise durch Vererbung, im Falle einer objektorientierten Programmiersprache, erreicht werden.\\
\end{longtabu}
}\label{tab:APIUsabilityProperties}
%\begin{table}
%	\caption{Eigenschaften/Ziele des Qualitätsmerkmals \enquote{Benutzbarkeit}\newline (verändert nach \cite[14-23]{apiDesign})}
%	\label{tab:APIUsabilityProperties}
%	\begin{tabu}{|p{0.25\textwidth}|p{0.7\textwidth}|}
%		\hline
%		\rowfont[c]{\bfseries}
%		\taburowcolors 1{tableheadcolor .. tableheadcolor}
%		Eigenschaft/Ziel & Beschreibung\\
%		\hline
%		\taburowcolors 2{tablebodycolor .. tablerowcolor}
%		Konsistent & Gemeint ist damit das Entscheidungen, hinsichtlich des Entwurfs, einheitlich im Quellcode angewandt werden. Das betrifft beispielsweise die Namensgebung von Variablen oder Funktionen.\\
%		Intuitiv verständlich & Für dieses Ziel ist eine Konsistente \gls{API} unter Verwendung von Namenskonventionen unabdingbar. Grundlegend kann dabei gesagt werden das gleiche Dinge einheitliche Namen, aber auch ungleiche Dinge unterschiedliche Namen haben sollten. So können bereits durch bekannte Funktionen Rückschlüsse auf andere noch unbekannte gezogen werden. Ein konkretes Beispiel dafür sind \code{get}- und \code{set}-Methoden in der Java-Welt.\\
%		Dokumentiert & Eine ausführliche Dokumentation mit Beschreibungen zu den einzelnen Klassen, Methoden und Parametern, ist für eine einfache Benutzung dringend erforderlich. Zusätzlich sollten Beispiele diese Erläuterungen unterstreichen.\\
%		Einprägsam und leicht zu lernen & Damit eine \gls{API} einfach zu erlernen ist, sollten die ersten drei Punkte dieser Tabelle dringend erfüllt werden. Wichtig ist dabei eine geringe  Einstiegshürde, um potenzielle Nutzer nicht abzuschrecken. Prinzipiell ist es dabei immer sehr von Vorteil, wenn mit relativ wenig Code erste sichtbare Ergebnisse erzielt werden können.\\
%		Lesbaren Code fördern & Eine \gls{API} kann großen Einfluss auf die Lesbarkeit des Client-Codes haben und diesen so signifikant verbessern. Durch eine gute Lesbarkeit können zum Beispiel besser bzw. schneller Fehler entdeckt werden. Um einen möglichst schmalen Client-Code zu fördern, sollten \glspl{API} benötigte Hilfsmethoden bereitstellen, sofern dies möglich ist. Als Prämisse kann dabei angesehen werden, dass die \gls{API} alle Funktionen bereitstellen sollte, welche sie dem Client auch abnehmen kann.\\
%		Schwer falsch zu benutzen & Unerwartetes Verhalten aus Sicht den Nutzers sollte vermieden werden, um unerwartete Fehler zu verhindern und um die \gls{API} intuitiv bedienbar zu halten.\\
%		Minimal & Prinzipiell gilt es eine \gls{API} so klein wie möglich zu halten und Funktionen welche nicht unbedingt benötigt werden im zweifel weg zu lassen. Denn nachträglich können solche Elemente nicht mehr mit trivialen Aufwand entfernt werden. Außerdem lässt sich sagen das je größer die \gls{API}, desto größer die Komplexität.\\
%		Stabil & Durch Stabilität soll sichergestellt werden das Änderungen keine Auswirkung auf die Benutzer hat, welche eine ältere Version benutzen. Sind auftretende negative Auswirkungen unvermeidbar, sollten diese entweder ausführlich kommuniziert oder durch eine neue Version gekapselt werden.\\
%		Einfach erweiterbar & Um den Aufwand der Erweiterung einer \gls{API} möglichst einfach zu halten, muss die Anpassung von bestehenden Clients berücksichtigt werden. Der Idealfall ist dabei, wenn Client von Änderungen unberührt bleiben. Ein solches Verhalten kann beispielsweise durch Vererbung, im Falle einer objektorientierten Programmiersprache, erreicht werden.\\
%		\hline
%	\end{tabu}
%\end{table}

\subsubsection{Effizienz}
Unter dem Qualitätsmerkmal Effizienz kann beispielsweise der geringe Verbrauch von Akkuleistung oder des Datenvolumens bei Mobilen Geräten verstanden werden. Ein weiterer Aspekt kann aber auch die Skalierbarkeit einer \gls{API} sein, welcher bei einem großen Zuwachs von Aufrufen durchaus entscheidend für die Stabilität oder der Performance sein kann.

\subsubsection{Zuverlässigkeit}
Unter der Zuverlässigkeit einer \gls{API} kann die geringe Fehleranfälligkeit verstanden werden bzw. wie gut diese auf Fehler reagieren kann. Ein wichtiger Aspekt der dabei auf jeden Fall beachtet werden sollte ist die Rückgabe von standardisierten HTTP-Statuscodes. Dies ermöglicht dem Benutzer ein ordentliches und verständliches Feedback. Dieses kann noch wenn notwendig durch konkretisierte Fehlermeldungen ergänzt werden.

\subsection{Grundprinzipien von REST}\label{sec:basePrincipleREST}
\subsubsection{Eindeutige Identifikation von Ressourcen}
Für jede Ressourcen muss eine eindeutige Identifikation definiert werden. Im Web stehen dabei \glspl{URI} für diesen Zweck bereit. Die Wichtigkeit dieses Prinzips liegt nahe. Wenn beispielsweise Produkte von einem Online-Shop nicht eindeutig identifiziert werden könnten, dann wäre das beispielsweise für Werbezwecke mehr als unpraktisch. E-Mails mit personalisierter Werbung für Produkte wäre ohne eine eindeutige Identifikation dieser nicht bzw. sehr umständlich möglich.\\
\\
Wichtig zu beachten ist das mit \glspl{URI} nicht nur einzelne Ressourcen, sondern auch Ressourcenlisten identifiziert werden können. Um bei dem Beispiel von oben zu bleiben, könnte es eine \gls{URI} geben mit welcher ein einzelnes Produkt und eine mit welcher eine Liste von Produkten identifiziert werden kann. Dies ist kein Widerspruch gegen das Prinzip, welches besagt das jede Ressource eindeutig identifiziert werden muss, denn in diesem Fall wird die Liste als selbstständige Ressource betrachtet.

\subsubsection{Verwendung von Hypermedia}
Hypermedia als Begriff ist eine Zusammensetzung aus den Begriffen Hypertext und Multimedia. Dabei kann Hypermedia als Oberbegriff von Hypertext betrachtet werden, denn Hypermedia unterstützt nicht nur Texte, sondern auch andere Multimediale Inhalte, wie zum Beispiel Dokumente, Bilder, Videos oder Links. Letzteres kann für das Ausführen von Funktionen oder zum Navigieren innerhalb des Browsers verwendet werden und ist ein bekanntes Element in der \gls{HTML}. Daher kann \gls{HTML} auch als klassischer Vertreter des Hypermedia Formates betrachtet werden. Damit der Client weiß welche Aktionen bzw. welchen Pfaden er folgen kann, können diese ihm vom Server mithilfe von Links zur Verfügung gestellt werden.

\subsubsection{Verwendung von HTTP-Standardmethoden}
Um die vom Server bereitgestellten Links ordnungsgemäß auszuführen, müssen neben den \glspl{URI} auch einheitliche Schnittstellen bekannt sein. Das setzt voraus, dass alle Clients über Verwendung und Semantik der Schnittstellen Bescheid wissen. An dieser Stelle kommen die \gls{HTTP}-Standardmethoden zum Einsatz. Die Schnittstellen von \gls{HTTP} bestehen dabei im wesentlichen aus den Request-Methoden \code{GET}, \code{HEAD}, \code{POST}, \code{PUT} und \code{DELETE}, welche alle in der \gls{HTTP}-Spezifikation \cite{httpSpecification} definiert sind. Die Methoden \code{PATCH} oder auch \code{LINK} waren dabei nicht von Anfang an in der Spezifikation enthalten, sonder wurden erst nachträglich hinzugefügt.\\
\\
Ein Client kann beispielsweise mithilfe der Methode \code{GET}, ohne genaueres Wissen über die Ressource, eine Repräsentation dieser abfragen. Diese allgemeinen Schnittstellen werden für jede Ressource verwendet, wodurch eine mögliche Vorhersagbarkeit gewährleistet wird. Dies wiederum erfüllt ein Teil der Qualitätsmerkmale aus dem \hyperref[sec:qualityFeatures]{Kapitel~\ref{sec:qualityFeatures}}. Zusätzlich ist noch anzumerken das durch Benutzung der Methode \code{GET} keine unerwünschten Effekte befürchtet werden müssen, denn diese ist idempotent. Einfach ausgedrückt ist diese Methode ein lesender Zugriff auf eine Ressource und kann daher keine Änderung des Zustands hervorrufen.

\subsubsection{Unterschiedliche Repräsentationen von Ressourcen}
Um mit den Daten, welche eine \gls{API} zurückgibt, umgehen zu können, muss der Client wissen in welchem Format er die Daten zurückbekommen möchte. Mithilfe der Technologie \enquote{Content Negotiation}, welche durch das \gls{HTTP}-Protokoll bereitgestellt wird, kann der Client angeben in welchem Format er die Antwort erhalten möchte. Dabei besteht die Möglichkeit mehrere Formate, mit unterschiedlichen Prioritäten zu übergeben. Die gängigste Methode zur Übergabe der gewünschten Formate ist dabei diese im \code{Accept-Header} des \gls{HTTP}-Request mitzusenden.

\subsubsection{Statuslose Kommunikation}\label{sec:statelessCommunikation}
Das letzte Grundprinzip besagt das es keinen Sitzungsstatus, welcher auf dem Server über mehrere Anfragen gehalten wird, existieren darf. Der Kommunikationsstatus muss demzufolge in der Ressource selber oder im Client gespeichert werden. Durch die statuslose Kommunikation wird die Kopplung zwischen Server und Client verringert. Das wiederum bringt den Vorteil das beispielsweise ein Neustart des Servers den Client nicht stören oder sogar zum Absturz bringen würde. Dieser müsste nämlich davon gar nichts zwangsläufig mitbekommen. Ein weiterer nicht unerheblicher Vorteil welcher daraus resultiert ist die Möglichkeit der Lastverteilung auf unterschiedliche Serverinstanzen.

\subsection{HATEOAS}
\enquote{Hypermedia As The Engine Of Application State} oder kurz HATEOAS ist ein Design-Konzept, welches von vielen \glspl{API} die sich selber als \gls{REST}ful bezeichnen missachtet wird. \cite{restMustBeHypertextDriven} Der Begriff HATEOAS bzw. diese Aussage, welche dahinter steckt, kann nach Kai Spichale mit nachfolgenden Bedeutungen beschrieben werden \cite[156]{apiDesign}:
\begin{itemize}
	\item \enquote{»Hypermedia« ist eine Verallgemeinerung des Hypertexts mit multimedialen Anteilen. Beziehungen zwischen Objekten werden durch
		Hypermedia Controls abgebildet.}
	\item \enquote{Mit »Engine« ist ein Zustandsautomat gemeint. Die Zustände und
		Zustandsübergänge der »Engine« beschreiben das Verhalten der
		»Application«.}
	\item \enquote{Im Kontext von REST kann man »Application« mit Ressource
		gleichsetzen.}
	\item \enquote{Mit »State« ist der Zustand der Ressource gemeint, deren Zustandsübergänge durch die »Engine« definiert werden.}
\end{itemize}
Der Grundgedanke hinter diesen Konzept ist die Selbstbeschreibung einer \gls{API}. Das Ziel soll dabei sein, dass Clients nicht genau über die \gls{API} Bescheid wissen müssen, sondern der Server dem Client zeigt wie er durch die \gls{API} navigieren kann. Als Resultat des ganzen benötigt der Client nur das Wissen über die \gls{URL} des Einstiegs, alle weiteren Informationen bekommt er vom Server in Form von Links übermittelt.\\
\\
Durch dieses Konzept wird ein dynamischer Workflow erzeugt, wodurch der Server die volle Kontrolle über die \gls{API} behält. Damit ist es beispielsweise möglich anhand des anzufragenden Clients unterschiedliche Links bzw. Navigationspunkte auszuliefern oder Links sogar komplett auszutauschen, ohne das der Client davon etwas bemerken muss. Aber um diese Vorteile nutzen zu können ist es natürlich notwendig das Clients die bereitgestellten Links auch verwenden und diese nicht fest einprogrammiert haben.

\section{Das Build-Tool Gradle}
Gradle ist ein Open-Source Build-Tool, welches in erster Linie für die Java-Welt entwickelt wurde, aber mittlerweile auch andere Sprachen wie zum Beispiel Kotlin unterstützt. Es basiert auf den Erfahrungen von anderen großen Build-Tools wie Ant und Maven und hat damit große Akzeptanz gefunden. Indiz dafür ist der Wechsel zu Gradle von einigen großen und bekannten Projekten, wie beispielsweise Android oder das Framework Spring.\\
\\
Die in diesem Kapitel behandelten Fakten und Erklärungen entstammen aus dem Buch \cite{introducingGradle} von Balaji Varanasi und Sudha Belida.

\subsection{Eigenschaften von Gradle}
\subsubsection{Declarative Dependency Management}
Gradle ist nicht nur ein Tool um eigene Anwendungen zu bauen, sondern dient auch dazu die Abhängigkeitsstruktur dieser aufzulösen. Eine manuelle Auflösung dieser Strukturen, mit allen zugehörigen Versionen, kann je nach Tiefe sehr aufwendig werden. Denn viele große Bibliotheken, wie beispielsweise Spring, bringen selber Abhängigkeiten mit, welche wiederum eigene mitbringen können. Mit Gradle genügt es ausschließlich die Projektspezifischen Abhängigkeiten, mit den zugehörigen Versionen zu definieren. Eine Konfiguration wie und welche Unterabhängigkeiten aufgelöst werden müssen ist dabei nicht notwendig, denn darum kümmert sich Gradle automatisch. Es ist demzufolge nur wichtig über das \enquote{Was} aber nicht über das \enquote{Wie} Bescheid zu wissen.

\subsubsection{Declarative Builds}
Damit Skripte für den Build-Prozess einfach und verständlich sind, verwendet Gradle dafür eine \gls{DSL} auf Basis der Programmiersprache Groovy. Dadurch werden eine Reihe von Sprach-Elementen bereitgestellt, welche einfach zusammengestellt werden können und ihre Absicht klar zum Ausdruck bringen.

\subsubsection{Build by Convention}
Um den Konfigurationsaufwand von Projekten zu minimieren bietet Gradle eine Reihe von Standardwerten und Konventionen an. Durch die Einhaltung dieser werden Build-Skripte sehr prägnant, sie sind aber dennoch nicht an diese gebunden. Da die Skripte auf Groovy basieren können die Konventionen leicht, durch schreiben von Groovy-Code, umgangen werden.

\subsubsection{Incremental Builds}
In größeren Projekten kommt es oft zu sehr langsamen Build-Zeiten, weil andere Tools im Gegensatz zu Gradle versuchen den Code immer zu säubern und neu aufzubauen. Durch die inkrementellen Builds, welche Gradle bereitstellt, kann dieses Problem umgangen werden. Tasks die der Build-Prozess ausführt, werden sofern keine Änderungen festgestellt wurden übersprungen. Dafür wird überprüft ob sich Ein- oder Ausgänge eines Tasks geändert haben.

\subsubsection{Gradle Wrapper}
Mithilfe dieses Features ist es möglich Projektespezifische Tasks auszuführen, obwohl keine Installation von Gradle auf dem System vorhanden ist. Der Gradle Wrapper stellt dafür eine Batch-Datei für Windows- und ein Shell-Skript für Linux- bzw. Mac-Umgebungen bereit. Ein weiterer Vorteil ist der Einsatz in \gls{CI} Servern, welche mithilfe des Gradle-Wrappers keine zusätzlichen Konfigurationen benötigen, um die Build-Prozesse auszuführen.

\subsubsection{Plugins}
Mithilfe von Plugins bzw. Erweiterungen kann die Funktionalität von Gradle beliebig erweitert oder angepasst werden. Dabei dienen diese als Kapselung von Build- oder Task-Logik und können bequem verteilt bzw. in anderen Projekten wiederverwendet werden. Somit ist beispielsweise eine Unterstützung von zusätzlichen Programmiersprachen ohne weiteres möglich.

\subsection{Verwaltung von Projekten und Tasks}
Innerhalb von Gradle  wird zwischen zwei grundlegenden Build-Bereichen unterschieden, den Projekten und den Tasks. Gradle kann dabei für ein oder mehrere Projekte verwendet werden, wobei jedes Projekt wiederum einen oder mehrere Tasks beinhalten kann.

\subsubsection{Projekte}
Standardmäßig wird innerhalb des Projektverzeichnisses nach der Datei \code{build.gradle} gesucht, welche ein Projekt identifiziert und in welcher die benötigten Tasks definiert werden. Es ist dabei möglich die \code{build.gradle} Datei umzubenennen, dadurch muss aber der geänderte Name bei einem Aufruf eines Tasks explizit mit übergeben werden.\\
\\
Zusätzlich zur Definition von Tasks dient die Build-Datei dazu weitere Informationen festzulegen. Darunter zählen beispielsweise Abhängigkeiten und Repositories. Gradle sucht dann in allen angegebenen Repositories nach den definierten Abhängigkeiten.\\
\\
Auch die Angabe des Namens, der Version und der Beschreibung des eigenen Projektes ist über diese Datei möglich. Des Weiteren kann auch ein Elternprojekt definiert werden.

\subsubsection{Tasks}
Die Tasks sind das Kernstück eines jeden Projektes, mithilfe dieser lässt sich der geschriebene Quellcode kompilieren, Tests starten oder fertig zusammengebaute Applikation auf einen Server veröffentlichen.\\
\\
Jeder Task verfügt dabei über die Funktionen \code{doFirst} und \code{doLast} um Code vor oder nach einem Task auszuführen. Mithilfe dieser Funktionen ist es beispielsweise möglich in den Prozess eines bestehenden Task einzugreifen, ohne dessen eigentliche Logik zu verändern. Durch die Funktion \code{dependsOn}, welche auf einen Task aufgerufen werden kann, ist es möglich Abhängigkeiten zwischen Tasks zu definieren. So kann die Ausführung eines bestimmten Tasks vor einem anderen erzwungen werden.\\
\\
Des Weiteren besteht die Möglichkeit bestimmte Typen für Tasks anzugeben. So können diese standardmäßig als \code{Zip}, \code{Copy}, \code{Exec} oder \code{Delete} definiert werden. \code{Copy} erlaubt dabei zum Beispiel das Kopieren von Dateien und \code{Exec} das Ausführen von Kommandozeilen-Befehlen.\\
\\
In dem \hyperref[lst:gradleTask]{Listing~\ref{lst:gradleTask}} wird ein Beispiel für ein kopierenden Task gezeigt. Dieser kopiert alle Dateien mit den Endungen \code{.js} und \code{.js.map}, aus dem Build-Verzeichnis der Source-Dateien, in ein Unterverzeichnis \code{js} des \code{dist}-Verzeichnisses. Dabei ist außerdem eine Abhängigkeit zum Build-Task definiert, wodurch dieser immer zuvor ausgeführt wird.
\begin{lstlisting}[style=lstStyleFramed, language=Gradle, caption={Beispiel: Gradle-Task}, label=lst:gradleTask, float]
task copyCompiledFilesIntoDist(type: Copy) {
	from "$buildDir/classes/kotlin/main/"
	into "${projectDir}/dist/js/"
	include "*.js"
	include "*.js.map"
}

copyCompiledFilesIntoDist.dependsOn(build)
\end{lstlisting}

\section{Schachnotationen FEN und SAN}\label{sec:chessNotation}
\gls{FEN} und \gls{SAN} sind Notationen welche für die elektronische Verarbeitung von Schachspielen entwickelt wurden. Beide Notationen werden als Text dargestellt und ermöglichen so eine statuslose Kommunikation. Die \gls{FEN} dient dabei zur Repräsentation eines ganzen Spielstandes und die \gls{SAN} zur Darstellung eines Spielzuges.\\
\\
Die \gls{FEN} setzt sich aus mehreren Teilen zusammen, welche aus der Figurenstellung, dem aktuellem Spieler, der Möglichkeit zur Rochade, dem Feld zum schlagen \enquote{en passant}, den Halbzügen und der aktuellem Zugnummer besteht. Die einzelnen Teile der Notation werden dabei durch Leerzeichen getrennt. Die \hyperref[fig:fen]{Abbildung~\ref{fig:fen}} stellt den Startspielstand eines Schachspiels in der \gls{FEN} dar.\\

\begin{figure}[H]
	\caption{Startposition eines Schachspiels in der FEN}
	rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
	\label{fig:fen}
\end{figure}\noindent
Die \gls{SAN} besteht im allgemeinen aus dem Buchstaben der bewegenden Spielfigur und dem Zielfeld. Zu beachten ist dabei das für eine Bauernfigur kein Buchstabe angegeben wird. Die \hyperref[fig:sanPawn]{Abbildung~\ref{fig:sanPawn}} zeigt den Zug eines Bauern vom Feld a2 nach a4 und die \hyperref[fig:sanKnight]{Abbildung~\ref{fig:sanKnight}} den eines Springers vom Feld b1 nach c3.
\begin{figure}[H]
	\IfDefined{RawFloats}{\RawFloats}
	\begin{minipage}[b]{.5\linewidth}
		\centering
		a4
		\captionsetup{justification=centering}
		\caption{Beispiel SAN: Bauer zieht von a2 nach a4}\label{fig:sanPawn}
	\end{minipage}%
	\begin{minipage}[b]{.5\linewidth}
		\centering
		Nc3
		\captionsetup{justification=centering}
		\caption{Beispiel SAN: Spring zieht von b1 nach c3}\label{fig:sanKnight}
	\end{minipage}
\end{figure}\noindent
Die Buchstabencodes der einzelnen Figuren sind in der \hyperref[tab:pieces]{Tabelle~\ref{tab:pieces}} aufgelistet. Dabei ist zu beachten das die Codes für die Farbe Schwarz klein und für die Farbe Weiß groß geschrieben werden. Dies gilt aber nur für die \gls{FEN}, denn in der \gls{SAN} werden diese immer groß geschrieben. Genauere Informationen zur \gls{FEN} und \gls{SAN} können in der Bachelorarbeit \cite[9-10]{kretzschmar} von Christoph Kretzschmar nachgelesen werden.
\begin{table}[H]
	\caption{Figurenbedeutung in der FEN und SAN (Quelle: \cite[Tabelle~2.1]{kretzschmar})}
	\label{tab:pieces}
	\begin{tabu}{rcccccc}
		\rowfont[c]{\bfseries}
		\taburowcolors 1{tableheadcolor .. tableheadcolor}
		\hline
		& R & N & B & Q & K & P \\
		\hline
		\taburowcolors 2{tablebodycolor .. tablerowcolor}
		Bedeutung & Rook & Knight & Bishop & Queen & King & Pawn \\
		Figur & Turm & Springer & Läufer & Königin & König & Bauer \\\hline
	\end{tabu}
\end{table}

\section{Schachregeln}
Für das reibungslose Verständnis dieser Arbeit empfiehlt es sich die Schachregeln zu kennen. Da eine detaillierte Erläuterung dieser aber den Rahmen der Arbeit sprengen würde, können sämtliche Regeln in dem Buch \cite{learnChess} nachgeschlagen werden. In diesem Buch sind neben den allgemeinen Regeln, auch die der Bewegung einzelnen Figuren zu finden. Zusätzlich sind noch eine Reihe von Tipps zum Einstieg und Testfragen zu bekannten Partien, mit beigefügten Lösungen, enthalten.