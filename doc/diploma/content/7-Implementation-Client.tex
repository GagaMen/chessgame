% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Implementation des Clients}
\section{Verwendete Bibliotheken/Frameworks}

\subsection{RequireJS}\label{sec:requireJs}
RequireJS ist ein für JavaScript entwickelte Bibliothek zum laden von Modulen. Dabei ist es für Nutzung innerhalb des Browsers optimiert, kann aber auch für andere Umgebungen genutzt werden. Ziel von solchen Bibliotheken wie RequireJs soll sein den eigenen Code zu beschleunigen und die Qualität zu steigern.\cite{requirejs}\\
\\
Für die Modulbeschreibung innerhalb von JavaScript stehen mehrere Formate bereit. RequireJS setzt dabei auf das Format \gls{AMD}. Das \hyperref[lst:amdExample]{Listing~\ref{lst:amdExample}} stellt ein einfaches Beispiel für die Definition eines \gls{AMD}-Moduls bereit. In dem Zeitschriftartikel \cite{jsModuleDefinitions} können zu den einzelnen Modul-Formaten und deren Einsatzmöglichkeiten nähere Informationen nachgelesen werden.
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Moduldefinition mittels \acrfull{AMD} \cite{requirejsExample}}, label=lst:amdExample]
define(['jquery'] , function ($) {
	return function () {};
});
\end{lstlisting}

\subsection{kotlinx.html}\label{sec:kotlinxHtml}
Die Kotlinx.html ist eine offiziell von JetBrains entwickelte Bibliothek, welche eine \gls{DSL} für das Erstellen bzw. Ergänzen von HTML-Code bereitstellt. Sie kann dabei für die \gls{JVM} oder JavaScript Plattform verwendet werden.\\
\\
Diese Bibliothek ermöglicht es den sämtlichen HTML-Code in Kotlin-Code auszulagern. Das bringt einen großen Vorteil mit, denn das Erstellen des Codes wir durch eine statisch Typisierung abgesichert. Dadurch können mögliche Fehler im HTML-Code bereits während der Übersetzung des Quellcodes erkannt werden. Vergessene oder gar falsch verschachtelte HTML-Tags werden dadurch vermieden. Ein Beispiel für die Verwendung stellt das \hyperref[lst:kotlinxHtmlExample]{Listing~\ref{lst:kotlinxHtmlExample}} dar, welches den HTML-Code aus \hyperref[lst:kotlinxHtmlParseExample]{Listing~\ref{lst:kotlinxHtmlParseExample}} generiert.
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Verwendung der Bibliothek kontlinx.html \cite{kotlinxExample}}, label=lst:kotlinxHtmlExample]
import kotlinx.html.*
import kotlinx.html.dom.*

val myDiv = document.create.div {
	p { +"text inside" }
}
\end{lstlisting}
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Verwendung der Bibliothek kotlinx.html (Ergebnis)}, label=lst:kotlinxHtmlParseExample]
<div>
	<p>
		text inside
	</p>
</div>
\end{lstlisting}

\subsection{kotlinx.serialization}\label{sec:kotlinxSerialization}


\subsection{kotlinx.coroutines}\label{sec:kotlinxCoroutines}


\section{Implementierung der Request-Funktionalität}
Um die Kommunikation mit dem \gls{REST}ful Server, welche in den Anforderungen im \hyperref[sec:anforderungenClient]{Kapitel~\ref{sec:anforderungenClient}} definiert wurden, zu gewährleisten, bedarf es einer Reihe von Funktionen zum senden eines Requestes. Für jeden Request-Typ wird dabei eine eigene statische Methode definiert. Um anschließend diese Funktionen nutzen zu können, müssen diese gegebenenfalls eine Parameterlist und eine Antwortfunktion verarbeiten können. Als Rückgabe wird das JavaScript \code{Promise} Objekt genutzt, mit wessen Hilfe und der Bibliothek \enquote{kotlinx.coroutines}\footnote{siehe \hyperref[sec:kotlinxCoroutines]{Kapitel~\ref{sec:kotlinxCoroutines}}} die Möglichkeit besteht auf den Abschluss eines Requestes zu warten. Dies ist teilweise notwendig, da JavaScript grundlegend Asynchron arbeitet.\\
\\
Das \hyperref[lst:requestUtility]{Listing~\ref{lst:requestUtility}} zeigt die Implementierung der statischen Methoden für die Request-Typen \code{GET} und \code{POST}. Alle weiteren Request-Typen sind ebenfalls definiert, werden aber in dieser Veranschaulichung vernachlässigt. Die Funktion \code{parseParams} verarbeitet dabei die übergebene Parameterliste, welche aus Key-Value-Paaren bestehen muss. Dabei dient der Key in Form eines Strings als Parameterindikator und der Value als Wert des Parameters. Der Funktionsparameter \code{callback} kann in Form eines Lambda-Ausdrucks, bei Funktionsaufruf definiert werden und wird anschließen nach Erhalt des \gls{HTTP}-Response ausgeführt.\\
\\
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Implementierung der Request-Methoden \code{GET} und \code{POST}, inklusiver der Parameterverarbeitung}, label=lst:requestUtility, float]
class RequestUtility {
	companion object {
		fun get(
				url: String, 
				vararg params: Pair<String, Any> = arrayOf(), 
				callback: ((Event) -> dynamic)? = null
		): Promise<XMLHttpRequest> {
			return Promise { resolve, _ ->
				val request = XMLHttpRequest()
				
				if (params.isNotEmpty()) request.open("GET", "$url?${parseParams(params)}")
				else request.open("GET", url)
				
				request.addEventListener("load", callback)
				request.addEventListener("load", { resolve(request) })
				request.send()
			}
		}
	
		fun post(
				url: String, 
				vararg params: Pair<String, Any> = arrayOf(), 
				callback: ((Event) -> dynamic)? = null
		): Promise<XMLHttpRequest> {
			return Promise { resolve, _ ->
				val request = XMLHttpRequest()
				
				request.open("POST", url)
				request.addEventListener("load", callback)
				request.addEventListener("load", { resolve(request) })
				request.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
				request.send(parseParams(params))
			}
		}
	
		private fun parseParams(params: Array<out Pair<String, Any>>): String {
			var paramsAsString = ""
			
			params.forEach { (key, value) ->
				if (paramsAsString != "") paramsAsString += "&"
				paramsAsString += "$key=$value"
			}
			
			// %2B is the '+' character. If using the '+' character it will parse into a space character
			paramsAsString = paramsAsString.replace("+", "%2B")
			
			return paramsAsString
		}
	}
}
\end{lstlisting}
Wie anschließend ein Request gesendet werden kann, zeigt das \hyperref[lst:requestPlayerList]{Listing~\ref{lst:requestPlayerList}}. In diesem wird das Anfordern der Playerliste mittel \code{GET}-Request gezeigt. Dabei wird es in einer \code{launch}-Umgebung ausgeführt, welche das Warten auf die Antwort ermöglicht. Hinter dem Funktionsaufruf wird der Lambda-Ausdruck definiert, welcher die Antwort parst und anschließend alle Player dem Client-Objekt hinzufügt.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Funktionsaufruf eines \code{GET}-Requestes am Beispiel der Playerliste}, label=lst:requestPlayerList, float]
launch {
	get("${client.config.serverRootUrl}players") {
		if (it.target is XMLHttpRequest) {
			val playerHashMap = JSON.parse<PlayerHashMap>((it.target as XMLHttpRequest).responseText)
			playerHashMap.player.forEach { client.addPlayer(it.value) }
		}
	}.await()
}
\end{lstlisting}