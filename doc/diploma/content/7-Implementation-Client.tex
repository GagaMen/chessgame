% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Implementation des Clients}
\section{Verwendete Bibliotheken/Frameworks}

\subsection{RequireJS}\label{sec:requireJs}
RequireJS ist ein für JavaScript entwickelte Bibliothek zum laden von Modulen. Dabei ist es für Nutzung innerhalb des Browsers optimiert, kann aber auch für andere Umgebungen genutzt werden. Ziel von solchen Bibliotheken wie RequireJs soll sein den eigenen Code zu beschleunigen und die Qualität zu steigern.\cite{requirejs}\\
\\
Für die Modulbeschreibung innerhalb von JavaScript stehen mehrere Formate bereit. RequireJS setzt dabei auf das Format \gls{AMD}. Das \hyperref[lst:amdExample]{Listing~\ref{lst:amdExample}} stellt ein einfaches Beispiel für die Definition eines \gls{AMD}-Moduls bereit. In dem Zeitschriftartikel \cite{jsModuleDefinitions} können zu den einzelnen Modul-Formaten und deren Einsatzmöglichkeiten nähere Informationen nachgelesen werden.
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Moduldefinition mittels \acrfull{AMD} \cite{requirejsExample}}, label=lst:amdExample]
define(['jquery'] , function ($) {
	return function () {};
});
\end{lstlisting}

\subsection{kotlinx.html}\label{sec:kotlinxHtml}
Die Kotlinx.html ist eine offiziell von JetBrains entwickelte Bibliothek, welche eine \gls{DSL} für das Erstellen bzw. Ergänzen von HTML-Code bereitstellt. Sie kann dabei für die \gls{JVM} oder JavaScript Plattform verwendet werden.\\
\\
Diese Bibliothek ermöglicht es den sämtlichen HTML-Code in Kotlin-Code auszulagern. Das bringt einen großen Vorteil mit, denn das Erstellen des Codes wir durch eine statisch Typisierung abgesichert. Dadurch können mögliche Fehler im HTML-Code bereits während der Übersetzung des Quellcodes erkannt werden. Vergessene oder gar falsch verschachtelte HTML-Tags werden dadurch vermieden. Ein Beispiel für die Verwendung stellt das \hyperref[lst:kotlinxHtmlExample]{Listing~\ref{lst:kotlinxHtmlExample}} dar, welches den HTML-Code aus \hyperref[lst:kotlinxHtmlParseExample]{Listing~\ref{lst:kotlinxHtmlParseExample}} generiert.
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Verwendung der Bibliothek kontlinx.html \cite{kotlinxExample}}, label=lst:kotlinxHtmlExample]
import kotlinx.html.*
import kotlinx.html.dom.*

val myDiv = document.create.div {
	p { +"text inside" }
}
\end{lstlisting}
\begin{lstlisting}[style=lstStyleFramed, caption={Beispiel: Verwendung der Bibliothek kotlinx.html (Ergebnis)}, label=lst:kotlinxHtmlParseExample]
<div>
	<p>
		text inside
	</p>
</div>
\end{lstlisting}

\subsection{kotlinx.serialization}\label{sec:kotlinxSerialization}


\subsection{kotlinx.coroutines}\label{sec:kotlinxCoroutines}


\section{Implementierung der Request-Funktionalität}
Um die Kommunikation mit dem \gls{REST}ful Server, welche in den Anforderungen im \hyperref[sec:anforderungenClient]{Kapitel~\ref{sec:anforderungenClient}} definiert wurden, zu gewährleisten, bedarf es einer Reihe von Funktionen zum senden eines Requestes. Für jeden Request-Typ wird dabei eine eigene statische Methode definiert. Um anschließend diese Funktionen nutzen zu können, müssen diese gegebenenfalls eine Parameterlist und eine Antwortfunktion verarbeiten können. Als Rückgabe wird das JavaScript \code{Promise} Objekt genutzt, mit wessen Hilfe und der Bibliothek \enquote{kotlinx.coroutines}\footnote{siehe \hyperref[sec:kotlinxCoroutines]{Kapitel~\ref{sec:kotlinxCoroutines}}} die Möglichkeit besteht auf den Abschluss eines Requestes zu warten. Dies ist teilweise notwendig, da JavaScript grundlegend Asynchron arbeitet.\\
\\
Das \hyperref[lst:requestUtility]{Listing~\ref{lst:requestUtility}} zeigt die Implementierung der statischen Methoden für die Request-Typen \code{GET} und \code{POST}. Alle weiteren Request-Typen sind ebenfalls definiert, werden aber in dieser Veranschaulichung vernachlässigt. Die Funktion \code{parseParams} verarbeitet dabei die übergebene Parameterliste, welche aus Key-Value-Paaren bestehen muss. Dabei dient der Key in Form eines Strings als Parameterindikator und der Value als Wert des Parameters. Der Funktionsparameter \code{callback} kann in Form eines Lambda-Ausdrucks, bei Funktionsaufruf definiert werden und wird anschließen nach Erhalt des \gls{HTTP}-Response ausgeführt.\\
\\
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Implementierung der Request-Methoden \code{GET} und \code{POST}, inklusiver der Parameterverarbeitung}, label=lst:requestUtility, float]
class RequestUtility {
	companion object {
		fun get(
				url: String, 
				vararg params: Pair<String, Any> = arrayOf(), 
				callback: ((Event) -> dynamic)? = null
		): Promise<XMLHttpRequest> {
			return Promise { resolve, _ ->
				val request = XMLHttpRequest()
				
				if (params.isNotEmpty()) request.open("GET", "$url?${parseParams(params)}")
				else request.open("GET", url)
				
				request.addEventListener("load", callback)
				request.addEventListener("load", { resolve(request) })
				request.send()
			}
		}
	
		fun post(
				url: String, 
				vararg params: Pair<String, Any> = arrayOf(), 
				callback: ((Event) -> dynamic)? = null
		): Promise<XMLHttpRequest> {
			return Promise { resolve, _ ->
				val request = XMLHttpRequest()
				
				request.open("POST", url)
				request.addEventListener("load", callback)
				request.addEventListener("load", { resolve(request) })
				request.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
				request.send(parseParams(params))
			}
		}
	
		private fun parseParams(params: Array<out Pair<String, Any>>): String {
			var paramsAsString = ""
			
			params.forEach { (key, value) ->
				if (paramsAsString != "") paramsAsString += "&"
				paramsAsString += "$key=$value"
			}
			
			// %2B is the '+' character. If using the '+' character it will parse into a space character
			paramsAsString = paramsAsString.replace("+", "%2B")
			
			return paramsAsString
		}
	}
}
\end{lstlisting}
Wie anschließend ein Request gesendet werden kann, zeigt das \hyperref[lst:requestPlayerList]{Listing~\ref{lst:requestPlayerList}}. In diesem wird das Anfordern der Playerliste mittel \code{GET}-Request gezeigt. Dabei wird es in einer \code{launch}-Umgebung ausgeführt, welche das Warten auf die Antwort ermöglicht. Hinter dem Funktionsaufruf wird der Lambda-Ausdruck definiert, welcher die Antwort parst und anschließend alle Player dem Client-Objekt hinzufügt.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Funktionsaufruf eines \code{GET}-Requestes am Beispiel der Playerliste}, label=lst:requestPlayerList, float]
launch {
	get("${client.config.serverRootUrl}players") {
		if (it.target is XMLHttpRequest) {
			val playerHashMap = JSON.parse<PlayerHashMap>((it.target as XMLHttpRequest).responseText)
			playerHashMap.player.forEach { client.addPlayer(it.value) }
		}
	}.await()
}
\end{lstlisting}

\section{Implementierung des Polling-Verfahrens}
Für die Umsetzung des Polling-Verfahrens, welches in den Anforderungen aus dem \hyperref[sec:anforderungenClient]{Kapitel~\ref{sec:anforderungenClient}}, verlagt wurde, muss mehreres gewährleistet werden. Zu aller erst muss das Polling gestartet und gestoppt werden können. Des weiteren muss die Möglichkeit bestehen eine Aufgabe zu definieren, welche nach dem Start des Pollings rekursiv ausgeführt wird. Zwischen den rekursiven Aufrufen der Aufgabe soll eine Zeit-Wert definiert werden können, welchen der Prozess wartet bevor er sich erneut selber aufruft. Sobald der Polling-Prozess angehalten wurde, muss der rekursive Aufruf unterbrochen werden.\\
\\
In dem \hyperref[lst:pollingUtility]{Listing~\ref{lst:pollingUtility}} wurden diese Anforderungen an das Polling-Verfahren implementiert. Die Property \code{stopPolling} gibt dabei an, ob der rekursive Prozess unterbrochen werden soll. Mithilfe der Wartezeit und der auszuführende Aufgabe als Parameter der \code{start}-Funktion, kann das Polling eingeleitet werden. Dafür wird die Property \code{stopPolling} auf \code{false} gesetzt und anschließend die Rekursion gestartet. Die \code{stop}-Funktion setzt die Property \code{stopPolling} auf \code{true}, was wiederum in der rekursiven Funktion \code{sendPollingRequest} zu einer Unterbrechung führt.\\
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Implementierung des Polling-Verfahrens}, label=lst:pollingUtility, float]
class PollingUtility {
	private var stopPolling = true
	
	fun start(delayTime: Int, pollingTask: () -> Unit) {
		stopPolling = false
		sendPollingRequest(delayTime, pollingTask)
	}
	
	fun stop() {
		stopPolling = true
	}
	
	private fun sendPollingRequest(delayTime: Int, pollingTask: () -> Unit) {
		if (stopPolling) return
		launch {
			pollingTask()
			delay(delayTime)
			sendPollingRequest(delayTime, pollingTask)
		}
	}
}
\end{lstlisting}
\\
Um anschließend die Klasse \code{PollingUtility} zu nutzen, muss ausschließlich eine Variable von dieser angelegt und die \code{start}-Funktion gerufen werden. Dabei wird, wie im \hyperref[lst:pollingUsage]{Listing~\ref{lst:pollingUsage}} zu sehen, die Wartezeit in Millisekunden und die Aufgabe übergeben. Als Integer muss dabei die Wartezeit und als Lambda-Ausdruck die Aufgabe übergeben werden. Innerhalb der Polling-Aufgabe werden in dem Beispiel alle Draws eines Matches angefordert, anschließend wird überprüft ob neue Draws existieren und wenn ja werden die neuen zum Match hinzugefügt.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Einbindung bzw. Nutzung der \code{PollingUtility} Klasse}, label=lst:pollingUsage, float]
val pollingDraw = PollingUtility()

pollingDraw.start(client.config.pollingDelayTime) {
	get("${client.config.serverRootUrl}matches/$matchId/draws") {
		if (it.target is XMLHttpRequest) {
			val drawList = JSON.parse<DrawList>((it.target as XMLHttpRequest).responseText)
			if (match.history.size != drawList.draws.size) {
				match.history.forEach { draw ->
					drawList.draws.removeAll { it.id == draw.id }
				}
				drawList.draws.forEach { draw ->
					match.addDraw(draw, true)
				}
			}
		}
	}
}
\end{lstlisting}