% !TeX encoding=utf8
% !TeX spellcheck = de_DE
% !TeX root = ../Diploma.tex

\chapter{Implementation des Servers}
Inhalt dieses Kapitels soll die Umsetzung des Konzeptes aus \hyperref[sec:conceptServer]{Kapitel~\ref{sec:conceptServer}} sein. Dafür wird im ersten Abschnitt auf die Bibliotheken bzw. Frameworks eingegangen, welche für die Umsetzung verwendet wurden. Der zweite Teil wird die Anbindung zur Datenbank näher betrachtet. Anschließend folgt eine Erläuterung zur Konfiguration von Content-Negotiation einer Spring-Applikation. In dem vierten Unterkapitel wird die Fehlerbehandlung bzw. das Exceptionhandling näher erläutert. Der letzte Abschnitt befasst sich mit der Ermittlung bzw. Analyse der Schachnotationen \gls{FEN} und \gls{SAN}.

\section{Verwendete Bibliotheken/Frameworks}
Die verwendeten Bibliotheken bzw. Frameworks sollen die Umsetzung der Anforderungen aus dem \hyperref[sec:anforderungen]{Kapitel~\ref{sec:anforderungen}} vereinfachen und beschleunigen. Dabei werden diese in den nachfolgenden \hyperref[sec:bibspring, sec:bibfasterxml]{Unterabschnitten~\ref{sec:bibspring} bis \ref{sec:bibfasterxml}} in den Punkten Zweck, Einrichtung und Verwendung näher betrachtet. 

\subsection{Spring}\label{sec:bibspring}
Spring wird als ein leichtgewichtiges Framework für die Umsetzung von Java Applikationen beschrieben. Dabei bezieht sich das leichtgewichtig nicht auf die Größe oder Anzahl der enthaltenen Klassen. Es ist eher als geringer Aufwand an Änderungen am eigenen Programmcode zu verstehen, um die Vorteile des Frameworks nutzen zu können. \cite{proSpring5} Spring biete eine Vielzahl an Einsatzmöglichkeiten, aber für die Umsetzung des Servers soll es für die Erzeugung der \gls{REST}-\gls{API} dienen.\\
\\
Um Spring in einem Projekt einzubinden, müssen die Zeilen aus dem \hyperref[lst:includeSpring]{Listing~\ref{lst:includeSpring}}, zusätzlich zu denen welche Kotlin benötigt\todo{ggf. irgendwo beschreiben wie man Kotlin in Gradle einbindet}, in der Build-Datei \enquote{build.gradle} eingefügt werden.
\begin{lstlisting}[style=lstStyleFramed, language=Gradle, caption={Einbindung des Spring Framework mithilfe von Gradle}, label=lst:includeSpring, float]
buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath "org.jetbrains.kotlin:kotlin-allopen:1.2.30"
		classpath "org.springframework.boot:spring-boot-gradle-plugin:1.5.4.RELEASE"
	}
}
apply plugin: "kotlin-spring"
apply plugin: "org.springframework.boot"

repositories {
	mavenCentral()
}

dependencies {
	compile "org.springframework.boot:spring-boot-starter-web"
}
\end{lstlisting}
Zu beachten ist dabei das Gradle nur eine Lösung für die Einbindung ist. Da aber für die Umsetzung ebenfalls Gradle verwendet wird, werden alle anderen Lösungen an dieser Stelle vernachlässigt.\\
\\ 
Für die Erstellung einer \gls{REST} \gls{API} muss zunächst ein Controller für eine Ressource angelegt werden, dabei ist es sinnvoll für jede einen eigenen Controller zu definieren. Innerhalb werden anschließend alle Einstiegspunkte erzeugt. Als Beispiel soll das \hyperref[lst:springcontroller]{Listing~\ref{lst:springcontroller}} in Form eines klassischen \code{Hello World} dienen. Dafür wird eine Klasse \code{GreetingController} mit einer Funktion \code{getGreeting} definiert. Als Parameter bekommt diese Funktion einen Namen übergeben, welcher standardmäßig den String \code{World} hält. An dieser Stelle kommt das Spring Framework ins Spiel. Dieses stellt eine Reihe von Annotation bereit, wobei \code{@RestController} einen Controller für die \gls{API}, \code{@GetMapping} einen Einstiegspunkt mit der Request-Methode \code{GET} und \code{@RequestParam} einen Parameter für diese Funktion definiert. 
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Beispiel: Spring Controller}, label=lst:springcontroller, float]
import org.springframework.web.bind.annotation.*

@RestController
class GreetingController {
	@GetMapping("/greeting")
	fun getGreeting(@RequestParam name: String = "World"): String {
		return "Hello $name!"
	}
}
\end{lstlisting}
Abschließend muss nur noch der Startpunkt für die Applikation definiert werden. Dafür wird wieder mithilfe einer Annotation ein Klasse erzeugt, welche aber keinerlei Informationen benötigt. Anschließend muss diese in der Main-Funktion, wie im \hyperref[lst:springmain]{Listing~\ref{lst:springmain}} zu sehen, gerufen werden. 
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Beispiel: Spring Application Class}, label=lst:springmain, float]
@SpringBootApplication
class Application

fun main(args: Array<String>) {
	SpringApplication.run(Application::class.java, *args)
}
\end{lstlisting}
Für eine detaillierte Beschreibung dieses Beispiels stehen auf den Internetseiten \cite{springTutorialKotlin} und \cite{springTutorial} weitere Informationen zur Verfügung.

\subsection{SQLite}\label{sec:bibsqlite}
SQLite ist eine OpenSource Bibliothek, welche ein dateibasiertes relationales Datenbanksystem bereitstellt. Der größte Unterschied zu anderen relationalen SQL-Datenbank besteht darin, das SQLite keinen separaten Serverprozess besitzt und somit als eingebettete Datenbank-Engine betrachtet werden kann. Alle Tabellen, Indizes, Trigger und Sichten einer Datenbank werden dabei in einem plattformunabhängigen Format in einer einzigen Datei gespeichert. Das bedeutet, dass Datenbankdateien bequem zwischen 32-Bit und 64-Bit-Systemen oder Little-Endian- und Big-Endian-Architekturen getauscht werden können.\cite{sqliteAbout}\\
\\
Für die Einbindung von SQLite in ein Projekt, mithilfe der Datenbankschnittstelle \gls{JDBC}, sind folgende Zeile in der Build-Datei von Gradle vonnöten:
\begin{lstlisting}[style=lstStyleFramed, language=Gradle, caption={Einbindung der Bibliothek SQLite mithilfe von Gradle}, label=lst:sqlite, float]
repositories {
	mavenCentral()
}

dependencies {
	compile group: 'org.xerial', name: 'sqlite-jdbc', version: '3.21.0.1'
}
\end{lstlisting}
Für ein einfaches Beispiel für die Verbindung zu einer SQLite Datenbank, die Erstellung von Tabellen und für das Absenden von SQL-Abfragen stellt \cite{sqliteJDBCTutorial} ein Tutorial bereit. Da für die Implementierung eine \gls{ORM} Bibliothek, welche im \hyperref[sec:bibormlite]{Kapitel~\ref{sec:bibormlite}} verwendet wird, wird eine nähere Betrachtung für die Verwendung von SQLite mithilfe des \gls{JDBC} Treibers vernachlässigt.

\subsection{ORMLite}\label{sec:bibormlite}
ORMLite ist ein OpenSource \gls{ORM} Projekt von Gray Watson, welches für Java entwickelt wurde, aber in Kotlin durch die Möglichkeit der Interoperabilität mit Java ebenfalls verwendet werden kann. Die Bibliothek unterstützt dabei eine Reihe von Datenbank-Systemen, wie zum Beispiel MySQL, Postgres oder SQLite.\\
\\
Um ORMLite in ein Gradle Projekt einzubinden müssen die Zeilen aus dem \hyperref[lst:includeORMLite]{Listing~\ref{lst:includeORMLite}} in die Build-Datei eingetragen werden. Dabei muss neben der Core-Bibliothek die \gls{JDBC}-Bibliothek von ORMLite eingebunden werden, welches für die Verbindung zur Datenbank zuständig ist. Da aber \gls{JDBC} mit mehreren Datenbank-Systemen kommunizieren kann muss noch, wie in dem \hyperref[sec:bibsqlite]{Kapitel~\ref{sec:bibsqlite}} für SQLite erläutert, der Datenbank-Treiber für das verwendete Datenbank-System eingebunden werden.
\begin{lstlisting}[style=lstStyleFramed, language=Gradle, caption={Einbindung der Bibliothek ORMLite mithilfe von Gradle}, label=lst:includeORMLite, float]
repositories {
	mavenCentral()
}

dependencies {
	compile "com.j256.ormlite:ormlite-core:5.1"
	compile "com.j256.ormlite:ormlite-jdbc:5.1"
}
\end{lstlisting}
Für die Persistierung zeigt das \hyperref[lst:ormPersistExample]{Listing~\ref{lst:ormPersistExample}} wie einzelne Klassen durch die von ORMLite bereitgestellten Annotationen verwendet werden können.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Beispiel: Persistierung einer Klasse mittels ORMLite \cite{ormlite}},label=lst:ormPersistExample, float]
@DatabaseTable(tableName = "accounts")
public class Account {
	@DatabaseField(id = true)
	private String name;
	
	@DatabaseField(canBeNull = false)
	private String password;
	...
	Account() {
		// all persisted classes must define a no-arg constructor with at least package visibility
	}
	...    
}
\end{lstlisting}
Der Zugriff auf die Datenbank erfolgt mittels \gls{DAO} Klassen, welche für jede Tabelle erzeugt werden müssen. Mit diesen \glspl{DAO} können anschließend Datensätze erstellt, bearbeitet und gelöscht werden. Zu dem stellen diese eine Reihe von Funktionen bereit um Datensätze abzufragen, wie zum Beispiel die Abfrage nach alle Datensätzen in der Datenbank oder nach einem bestimmten Objekt anhand seiner ID. Wenn diese Standard Funktionen nicht ausreichen besteht des weiteren die Möglichkeit komplexe Abfragen zu generieren mithilfe von einem sogenannten Query-Builder.
Zur Veranschaulich der Verwendung von ORMLite zeigt das \hyperref[lst:ormliteUsageExample]{Listing~\ref{lst:ormliteUsageExample}} ein Minmalbeispiel.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Beispiel: Verwendung von ORMLite (verändert nach \cite{ormlite})}, label=lst:ormliteUsageExample, float]
String databaseUrl = "jdbc:sqlite:path/to/account.db";
ConnectionSource connectionSource = new JdbcConnectionSource(databaseUrl);

Dao<Account,String> accountDao = DaoManager.createDao(connectionSource, Account.class);

TableUtils.createTable(connectionSource, Account.class);

String name = "Jim Smith";
Account account = new Account(name, "_secret");
accountDao.create(account);

Account account2 = accountDao.queryForId(name);
System.out.println("Account: " + account2.getPassword());

connectionSource.close();
\end{lstlisting}

\subsection{Fasterxml}\label{sec:bibfasterxml}
Mithilfe von Fasterxml werden inkrementelle Parser- und Generator-Abstraktionen bereitgestellt, welche in der Standardimplementierung die \gls{JSON} verarbeiten können. Dabei bietet das OpenSource-Projekt noch weitere Unterstützung für andere Datenformate, wie beispielsweise \gls{XML} oder \gls{CSV}, an.\cite{fasterxml}\\
\\
Für die Einbindung in ein Gradle-Projekt müssen die Zeilen aus dem \hyperref[lst:includeFasterxml]{Listing~\ref{lst:includeFasterxml}} in die Build-Datei hinzugefügt werden.
\begin{lstlisting}[style=lstStyleFramed, language=Gradle, caption={Einbindung der Bibliothek Fasterxml mithilfe von Gradle}, label=lst:includeFasterxml, float]
repositories {
	mavenCentral()
}

dependencies {
	compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: "$fasterxml_jackson_version"
	compile group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: "$fasterxml_jackson_version"
	compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: "$fasterxml_jackson_version"
}
\end{lstlisting}
Um anschließend den \gls{XML}-Support für ein Spring-Projekt einzurichten, müssen die Modelle mit Annotations erweitert werden. Das \hyperref[lst:exampleFasterxml]{Listing~\ref{lst:exampleFasterxml}} zeigt dabei wie ein Modell zu konfigurieren ist. Mit diesen Einstellungen wird die Content-Negotiation gewährleistet, welche im \hyperref[sec:contentNegotiation]{Kapitel~\ref{sec:contentNegotiation}} näher beleuchtet wird.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Beispiel: Verwendung von Fasterxml}, label=lst:exampleFasterxml, float]
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
data class Player(
	@XmlElement
	val id: Int = 0,
	@XmlElement
	var name: String = "",
	@XmlElement
	var password: String = ""
)
\end{lstlisting} 

\section{Anbindung an die Datenbank}
Für die Anbindung ist zu aller erst die Vorbereitung der Models, wie im \hyperref[sec:bibormlite]{Kapitel~\ref{sec:bibormlite}} erläutert, vonnöten.
Als nächstes muss vor einer Interaktion eine Verbindung zur Datenbank aufgebaut, alle benötigten Tabellen und \glspl{DAO} angelegt werden. Das \hyperref[lst:dbConnection]{Listing~\ref{lst:dbConnection}} zeigt dabei die Umsetzung  dieser Notwendigkeiten.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Verbindungsaufbau \& Initialisierung der SQLite Datenbank}, label=lst:dbConnection, float]
class DatabaseUtility {
	companion object {
		private var connection: JdbcConnectionSource? = null
		var playerDao: Dao<Player, Int>? = null
			get() {
				if (field == null) connect()
				return field
			}
		...
		private fun connect() {
			if (connection != null) return
			connection = JdbcConnectionSource("jdbc:sqlite:chessgame.db")
			createTables()
			createDaos()
		}

		private fun createTables() {
			TableUtils.createTableIfNotExists(connection, Player::class.java)
			...
		}
		
		private fun createDaos() {
			playerDao = DaoManager.createDao<Dao<Player, Int>, Player>(connection, Player::class.java)
			...
		}
	}
}
\end{lstlisting}
Dabei wird erst eine Verbindung aufgebaut sobald diese benötigt wird und zwar dann wenn eine \gls{DAO} geholt wird. Wenn ein \gls{DAO} angefordert wird, so wird die Verbindung ausschließlich aufgebaut sofern noch keine besteht. Ähnlich sieht das beim anlegen der Tabellen aus, denn diese werden ausschließlich nur dann angelegt sofern diese nicht existieren. Dieser Fall tritt beispielsweise nach einem Neustart des Servers auf.

\section{Spring-Konfiguration für Content-Negotiation}\label{sec:contentNegotiation}
Content-Negotiation ist laut \hyperref[sec:basePrincipleREST]{Kapitel~\ref{sec:basePrincipleREST}} ein wichtiges Qualitätsmerkmal für eine \gls{REST}-\gls{API}. Das Framework Spring\footnote{siehe \hyperref[sec:bibspring]{Kapitel~\ref{sec:bibspring}}} bietet auch hierfür Lösungen an, welche aber nicht standardmäßig zur Verfügung stehen. Die \gls{JSON} wird dabei ohne weitere Konfiguration unterstützt, nur für \gls{XML} müssen die Modelle mithilfe der Bibliothek Fasterxml\footnote{siehe \hyperref[sec:bibfasterxml]{Kapitel~\ref{sec:bibfasterxml}}} angepasst werden. Anschließend muss die Spring-Konfiguration, wie in \hyperref[lst:springContentNegotiation]{Listing~\ref{lst:springContentNegotiation}} zu sehen, erweitert werden. Die Implementierung zeigt dabei die Umsetzung der drei Strategien, welche in dem \hyperref[sec:anforderungen]{Kapitel~\ref{sec:anforderungen}} gefordert wurden.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Spring-Konfiguration der drei Content-Negotiation-Strategien}, label=lst:springContentNegotiation, float]
@Configuration
class WebConfig : WebMvcConfigurerAdapter() {
	override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer?) {
		configurer!!
			.favorPathExtension(true)
			.favorParameter(true)
			.parameterName("mediaType")
			.ignoreAcceptHeader(false)
			.useJaf(false)
			.defaultContentType(MediaType.APPLICATION_JSON)
			.mediaType("xml", MediaType.APPLICATION_XML)
			.mediaType("json", MediaType.APPLICATION_JSON)
	}
}
\end{lstlisting}
Die Internetseite \cite{springContentNegotiation} bietet für dieses Thema eine ausführlichere Erläuterung der einzelnen Strategien, wie diese angewendet und eingerichtet werden.

\section{Exceptionhandling}
Laut den Anforderungen aus dem \hyperref[sec:anforderungen]{Kapitel~\ref{sec:anforderungen}} soll der Server so wenig wie möglich anfällig für Fehler sein. Dafür ist der richtige Umgang und auch eine verständliche, für den Endnutzer lesbare, Fehlermeldung unerlässlich. Die Fehler können dabei in einzelnen Fehlerarten unterteilt werden.\\
\\
Wenn ein Nutzer eine Ressource an der \gls{URI} \code{/player/15} anfordert, aber kein Player mit der ID 15 existiert, dann wird ein Fehler mit dem \gls{HTTP}-Statuscode 400 zurückgegeben. Schon der Statuscode alleine signalisiert dem Nutzer das die angeforderte Ressource nicht gefunden wurde. Sollte ein Benutzer der \gls{API} einen Draw hinzufügen wollen aber der mitgeschickte Draw-Code in der \gls{SAN} nicht valide ist, so wird ein Fehler mit dem \gls{HTTP}-Statuscode 409 zurückgegeben. Dieser zeigt dem Nutzer das ein Konflikt, welchen er verursacht hat, aufgetreten ist. Wenn ein Nutzer den \gls{HTTP}-Statuscode 400 vom Server zurück erhält, so hat dieser einen \gls{URI} angefragt, welcher durch die \gls{REST}-\gls{API} nicht definiert wurde. Für alle weiteren Fehler welche nicht durch den Nutzer verursacht wurden, wird dieser mit dem \gls{HTTP}-Statuscode 500 zurückgeben. Da so ein Fehler nur zurückgegeben wird sofern ein unerwarteter Server-Fehler aufgetreten ist, sollte dieser gar nicht bzw. nur selten auftreten. Ein Beispiel könnte ein Verbindungsabbruch zur Datenbank sein, worauf der eigentliche Nutzer keinen Einfluss hat. Das \hyperref[lst:springExceptionHandling]{Listing~\ref{lst:springExceptionHandling}} zeigt dabei die Konfiguration der Spring-Applikation, für den Umgang mit Fehlern.\\
\\
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Spring-Konfiguration des Exceptionhandling}, label=lst:springExceptionHandling, float]
@RestControllerAdvice
class ExceptionHandler {
	@ExceptionHandler(value = [BadRequestException::class])
	@ResponseStatus(BAD_REQUEST)
	fun handleBadRequestException(ex: Exception, request: WebRequest): ErrorResponseObject {
		return generateErrorResponseObject(ex, request, BAD_REQUEST)
	}

	@ExceptionHandler(value = [IllegalArgumentException::class])
	@ResponseStatus(NOT_FOUND)
	fun handleIllegalArgumentException(ex: Exception, request: WebRequest): ErrorResponseObject {
		return generateErrorResponseObject(ex, request, NOT_FOUND)
	}
	
	@ExceptionHandler(value = [RuntimeException::class])
	@ResponseStatus(CONFLICT)
	fun handleRuntimeException(ex: Exception, request: WebRequest): ErrorResponseObject {
		return generateErrorResponseObject(ex, request, CONFLICT)
	}
	
	@ExceptionHandler(value = [Exception::class])
	@ResponseStatus(INTERNAL_SERVER_ERROR)
	fun handleUnknownException(ex: Exception, request: WebRequest): ErrorResponseObject {
		return generateErrorResponseObject(ex, request, INTERNAL_SERVER_ERROR)
	}
	
	private fun generateErrorResponseObject(ex: Exception, request: WebRequest, statusCode: HttpStatus): ErrorResponseObject {
		return ErrorResponseObject(...)
	}
}
\end{lstlisting}
Damit der \gls{API}-Benutzer nicht nur einen Statuscode zum aufgetretenen Fehler erhält, wird zusätzlich im Nachrichtenrumpf der Antwort ein Fehlerobjekt, in Form der Klasse \code{ErrorResponseObject} aus dem \hyperref[lst:errorResponseObject]{Listing~\ref{lst:errorResponseObject}}, mitgeschickt. Dieses hält einen Zeitstempel, den Statuscode, die Bezeichnung des Statuscodes, welche Exception den Fehler verursacht hat, eine detaillierte Fehlermeldung und den Pfad an welchen der Fehler aufgetreten ist. Das Fehlerobjekt wird dabei in dem angeforderten Format zurückgegeben\footnote{siehe \hyperref[sec:contentNegotiation]{Kapitel~\ref{sec:contentNegotiation}}}.
\begin{lstlisting}[style=lstStyleFramed, language=Kotlin, caption={Spring-Konfiguration des Exceptionhandling}, label=lst:errorResponseObject, float]
class ErrorResponseObject(
	val timestamp: Date = Date(),
	val statusCode: Int = 500,
	val error: HttpStatus = HttpStatus.INTERNAL_SERVER_ERROR,
	val exception: String = "",
	val message: String = "No message available",
	val path: String = ""
) {
override fun toString(): String {
	return "ErrorResponseObject{" +
			"timestamp=" + timestamp +
			", status=" + statusCode +
			", error=" + error +
			", exception=" + exception +
			", message=" + message +
			", path=" + path +
			'}'.toString()
	}
}
\end{lstlisting}

\section{Analyse/Ermittlung der FEN bzw. SAN}
Nach den Anforderungen aus dem \hyperref[sec:anforderungen]{Kapitel~\ref{sec:anforderungen}} wurde definiert, das Änderungen an einem Match ausschließlich über das hinzufügen eines Draws erfolgen sollen. Trotzdem muss eine Validierung des übermittelten Draw-Code durchgeführt werden, um zu überprüfen das dieser auch möglich ist. Dafür wurde der regulärer Ausdruck aus der \hyperref[fig:regexSAN]{Abbildung~\ref{fig:regexSAN}} entwickelt, welcher in acht Teile bzw. Gruppen unterteilt werden kann.\\
\\
\begin{figure}
	$\underbrace{([KQBNR])?}_{1}\underbrace{([a-h]|[1-8])?}_{2}\underbrace{(x)?}_{3}\underbrace{([a-h])}_{4}\underbrace{([1-8])}_{5}\underbrace{([QBRN])?}_{6}\underbrace{(e\textbackslash.p\textbackslash.)?}_{7}\underbrace{(\textbackslash+\{1,2\}|\#)?}_{8}$
\caption{Regulärer Ausdruck zur Validierung eines Strings in der SAN}
\label{fig:regexSAN}
\end{figure}
Der erste Part ermittelt dabei die Art der Spielfigur. Anhand des Fragezeichen-Symbols ist zu sehen  das dieser Teil optional ist, was dran liegt das kein Buchstabe angegeben wird wenn eine Bauernfigur gezogen wurde. Der zweite Teil zeigt an von welcher Spalten oder Reihe die Figur gestartet ist. Diese Information is notwendig wenn zwei Figuren der selben Art auf das Zielfeld gelangen können. Part drei gibt an ob eine Figur geschmissen wurde. In den Abschnitten vier und fünf wird das Zielfeld ermitteln, wobei der vierte Part die Spalte und der fünfte die Reihe darstellt. Teil sechs gibt die Art der Spielfigur an in welche sich ein Bauer umwandelt, wenn er die hinterste Reihe erreicht hat. Der vorletzte Part zeigt qn ob ein \enquote{Schlagen im Vorbeigehen} bzw. ein \enquote{Schlagen en passant} durchgeführt wurde. Im letzten Abschnitt ermittelt ob der Draw zu einem Schach oder einem Schachmatt führt. Dabei werden zwei Schreibweise für ein Schachmatt akzeptiert, einmal \enquote{++} und zum anderen \enquote{\#}. Zu beachten ist das mithilfe des regulären Ausdrucks nicht ermittelt werden kann, ob eine Rochade durchgeführt wurde. Dies muss zuvor separat geprüft werden.\\
\\
Mithilfe des regulären Ausdrucks kann anschließend anhand der Figurenstellung, welche im Match gespeichert sind, überprüft werden ob der Draw valide ist. Dafür wird als erstes das Startfelder ermittelt, sofern dieses nicht als Request-Parameter mit übergeben wurde. Wichtig hierbei ist das immer nur ein einziges Startfeld ermittelt werden darf, hierfür müssen ggf. die Informationen aus dem zweiten Teil des regulären Ausdrucks heran gezogen werden. Anschließend werden alle möglichen Felder ermittelt, zu welchen sich die Figur bewegen kann. Ist das übermittelte Zielfeld nicht enthalten, dann ist der Draw invalide. Wenn hingegen das Zielfeld enthalten ist, dann wird zusätzlich überprüft ob eine Figur geschlagen wird. Das gleiche gilt für Schlagen \enquote{en passant}, Schach und Schachmatt. Ist einer dieser Werte nicht oder falsch angegeben, dann ist der Draw invalide.\\
\\
Ist der Draw valide wird dieser schließlich in der Datenbank gespeichert und das dazugehörige Match wird angepasst. Dafür wird die Position der bewegten Figur, ggf. die geschlagene Figur, Informationen zu Schach oder Schachmatt, die Möglichkeit zur Rochade und die Halbzüge aktualisiert. Anhand der neuen Informationen kann anschließend der neue Wert der FEN ermittelt werden. Nach erfolgreicher Aktualisierung wird das Match in der Datenbank angepasst.